{"version":3,"file":"format_number.js","sourceRoot":"","sources":["../../../../../packages/common/src/i18n/format_number.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NumberFormatStyle, NumberSymbol, getLocaleNumberFormat, getLocaleNumberSymbol, getNumberOfCurrencyDigits} from './locale_data_api';\n\nexport const NUMBER_FORMAT_REGEXP = /^(\\d+)?\\.((\\d+)(-(\\d+))?)?$/;\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\nconst PATTERN_SEP = ';';\nconst GROUP_SEP = ',';\nconst DIGIT_CHAR = '#';\nconst CURRENCY_CHAR = '¤';\nconst PERCENT_CHAR = '%';\n\n/**\n * Transforms a number to a locale string based on a style and a format\n */\nfunction formatNumberToLocaleString(\n    value: number, pattern: ParsedNumberFormat, locale: string, groupSymbol: NumberSymbol,\n    decimalSymbol: NumberSymbol, digitsInfo?: string, isPercent = false): string {\n  let formattedText = '';\n  let isZero = false;\n\n  if (!isFinite(value)) {\n    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);\n  } else {\n    let parsedNumber = parseNumber(value);\n\n    if (isPercent) {\n      parsedNumber = toPercent(parsedNumber);\n    }\n\n    let minInt = pattern.minInt;\n    let minFraction = pattern.minFrac;\n    let maxFraction = pattern.maxFrac;\n\n    if (digitsInfo) {\n      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);\n      if (parts === null) {\n        throw new Error(`${digitsInfo} is not a valid digit info`);\n      }\n      const minIntPart = parts[1];\n      const minFractionPart = parts[3];\n      const maxFractionPart = parts[5];\n      if (minIntPart != null) {\n        minInt = parseIntAutoRadix(minIntPart);\n      }\n      if (minFractionPart != null) {\n        minFraction = parseIntAutoRadix(minFractionPart);\n      }\n      if (maxFractionPart != null) {\n        maxFraction = parseIntAutoRadix(maxFractionPart);\n      } else if (minFractionPart != null && minFraction > maxFraction) {\n        maxFraction = minFraction;\n      }\n    }\n\n    roundNumber(parsedNumber, minFraction, maxFraction);\n\n    let digits = parsedNumber.digits;\n    let integerLen = parsedNumber.integerLen;\n    const exponent = parsedNumber.exponent;\n    let decimals = [];\n    isZero = digits.every(d => !d);\n\n    // pad zeros for small numbers\n    for (; integerLen < minInt; integerLen++) {\n      digits.unshift(0);\n    }\n\n    // pad zeros for small numbers\n    for (; integerLen < 0; integerLen++) {\n      digits.unshift(0);\n    }\n\n    // extract decimals digits\n    if (integerLen > 0) {\n      decimals = digits.splice(integerLen, digits.length);\n    } else {\n      decimals = digits;\n      digits = [0];\n    }\n\n    // format the integer digits with grouping separators\n    const groups = [];\n    if (digits.length >= pattern.lgSize) {\n      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));\n    }\n\n    while (digits.length > pattern.gSize) {\n      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));\n    }\n\n    if (digits.length) {\n      groups.unshift(digits.join(''));\n    }\n\n    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));\n\n    // append the decimal digits\n    if (decimals.length) {\n      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join('');\n    }\n\n    if (exponent) {\n      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + '+' + exponent;\n    }\n  }\n\n  if (value < 0 && !isZero) {\n    formattedText = pattern.negPre + formattedText + pattern.negSuf;\n  } else {\n    formattedText = pattern.posPre + formattedText + pattern.posSuf;\n  }\n\n  return formattedText;\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as currency using locale rules.\n *\n * Use `currency` to format a number as currency.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `currency` is the string that represents the currency, it can be its symbol or its name.\n * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such\n *    as `USD` for the US dollar and `EUR` for the euro.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatCurrency(\n    value: number, locale: string, currency: string, currencyCode?: string,\n    digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n\n  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode !);\n  pattern.maxFrac = pattern.minFrac;\n\n  const res = formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);\n  return res\n      .replace(CURRENCY_CHAR, currency)\n      // if we have 2 time the currency character, the second one is ignored\n      .replace(CURRENCY_CHAR, '');\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as a percentage according to locale rules.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatPercent(value: number, locale: string, digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  const res = formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);\n  return res.replace(\n      new RegExp(PERCENT_CHAR, 'g'), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as text. Group sizing and separator and other locale-specific\n * configurations are based on the locale.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatNumber(value: number, locale: string, digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  return formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);\n}\n\ninterface ParsedNumberFormat {\n  minInt: number;\n  // the minimum number of digits required in the fraction part of the number\n  minFrac: number;\n  // the maximum number of digits required in the fraction part of the number\n  maxFrac: number;\n  // the prefix for a positive number\n  posPre: string;\n  // the suffix for a positive number\n  posSuf: string;\n  // the prefix for a negative number (e.g. `-` or `(`))\n  negPre: string;\n  // the suffix for a negative number (e.g. `)`)\n  negSuf: string;\n  // number of digits in each group of separated digits\n  gSize: number;\n  // number of digits in the last group of digits before the decimal separator\n  lgSize: number;\n}\n\nfunction parseNumberFormat(format: string, minusSign = '-'): ParsedNumberFormat {\n  const p = {\n    minInt: 1,\n    minFrac: 0,\n    maxFrac: 0,\n    posPre: '',\n    posSuf: '',\n    negPre: '',\n    negSuf: '',\n    gSize: 0,\n    lgSize: 0\n  };\n\n  const patternParts = format.split(PATTERN_SEP);\n  const positive = patternParts[0];\n  const negative = patternParts[1];\n\n  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ?\n      positive.split(DECIMAL_SEP) :\n      [\n        positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1),\n        positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)\n      ],\n        integer = positiveParts[0], fraction = positiveParts[1] || '';\n\n  p.posPre = integer.substr(0, integer.indexOf(DIGIT_CHAR));\n\n  for (let i = 0; i < fraction.length; i++) {\n    const ch = fraction.charAt(i);\n    if (ch === ZERO_CHAR) {\n      p.minFrac = p.maxFrac = i + 1;\n    } else if (ch === DIGIT_CHAR) {\n      p.maxFrac = i + 1;\n    } else {\n      p.posSuf += ch;\n    }\n  }\n\n  const groups = integer.split(GROUP_SEP);\n  p.gSize = groups[1] ? groups[1].length : 0;\n  p.lgSize = (groups[2] || groups[1]) ? (groups[2] || groups[1]).length : 0;\n\n  if (negative) {\n    const trunkLen = positive.length - p.posPre.length - p.posSuf.length,\n          pos = negative.indexOf(DIGIT_CHAR);\n\n    p.negPre = negative.substr(0, pos).replace(/'/g, '');\n    p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, '');\n  } else {\n    p.negPre = minusSign + p.posPre;\n    p.negSuf = p.posSuf;\n  }\n\n  return p;\n}\n\ninterface ParsedNumber {\n  // an array of digits containing leading zeros as necessary\n  digits: number[];\n  // the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n  exponent: number;\n  // the number of the digits in `d` that are to the left of the decimal point\n  integerLen: number;\n}\n\n// Transforms a parsed number into a percentage by multiplying it by 100\nfunction toPercent(parsedNumber: ParsedNumber): ParsedNumber {\n  // if the number is 0, don't do anything\n  if (parsedNumber.digits[0] === 0) {\n    return parsedNumber;\n  }\n\n  // Getting the current number of decimals\n  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;\n  if (parsedNumber.exponent) {\n    parsedNumber.exponent += 2;\n  } else {\n    if (fractionLen === 0) {\n      parsedNumber.digits.push(0, 0);\n    } else if (fractionLen === 1) {\n      parsedNumber.digits.push(0);\n    }\n    parsedNumber.integerLen += 2;\n  }\n\n  return parsedNumber;\n}\n\n/**\n * Parses a number.\n * Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/\n */\nfunction parseNumber(num: number): ParsedNumber {\n  let numStr = Math.abs(num) + '';\n  let exponent = 0, digits, integerLen;\n  let i, j, zeros;\n\n  // Decimal point?\n  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {\n    numStr = numStr.replace(DECIMAL_SEP, '');\n  }\n\n  // Exponential form?\n  if ((i = numStr.search(/e/i)) > 0) {\n    // Work out the exponent.\n    if (integerLen < 0) integerLen = i;\n    integerLen += +numStr.slice(i + 1);\n    numStr = numStr.substring(0, i);\n  } else if (integerLen < 0) {\n    // There was no decimal point or exponent so it is an integer.\n    integerLen = numStr.length;\n  }\n\n  // Count the number of leading zeros.\n  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) { /* empty */\n  }\n\n  if (i === (zeros = numStr.length)) {\n    // The digits are all zero.\n    digits = [0];\n    integerLen = 1;\n  } else {\n    // Count the number of trailing zeros\n    zeros--;\n    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;\n\n    // Trailing zeros are insignificant so ignore them\n    integerLen -= i;\n    digits = [];\n    // Convert string to array of digits without leading/trailing zeros.\n    for (j = 0; i <= zeros; i++, j++) {\n      digits[j] = Number(numStr.charAt(i));\n    }\n  }\n\n  // If the number overflows the maximum allowed digits then use an exponent.\n  if (integerLen > MAX_DIGITS) {\n    digits = digits.splice(0, MAX_DIGITS - 1);\n    exponent = integerLen - 1;\n    integerLen = 1;\n  }\n\n  return {digits, exponent, integerLen};\n}\n\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changes the parsedNumber in-place\n */\nfunction roundNumber(parsedNumber: ParsedNumber, minFrac: number, maxFrac: number) {\n  if (minFrac > maxFrac) {\n    throw new Error(\n        `The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);\n  }\n\n  let digits = parsedNumber.digits;\n  let fractionLen = digits.length - parsedNumber.integerLen;\n  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);\n\n  // The index of the digit to where rounding is to occur\n  let roundAt = fractionSize + parsedNumber.integerLen;\n  let digit = digits[roundAt];\n\n  if (roundAt > 0) {\n    // Drop fractional digits beyond `roundAt`\n    digits.splice(Math.max(parsedNumber.integerLen, roundAt));\n\n    // Set non-fractional digits beyond `roundAt` to 0\n    for (let j = roundAt; j < digits.length; j++) {\n      digits[j] = 0;\n    }\n  } else {\n    // We rounded to zero so reset the parsedNumber\n    fractionLen = Math.max(0, fractionLen);\n    parsedNumber.integerLen = 1;\n    digits.length = Math.max(1, roundAt = fractionSize + 1);\n    digits[0] = 0;\n    for (let i = 1; i < roundAt; i++) digits[i] = 0;\n  }\n\n  if (digit >= 5) {\n    if (roundAt - 1 < 0) {\n      for (let k = 0; k > roundAt; k--) {\n        digits.unshift(0);\n        parsedNumber.integerLen++;\n      }\n      digits.unshift(1);\n      parsedNumber.integerLen++;\n    } else {\n      digits[roundAt - 1]++;\n    }\n  }\n\n  // Pad out with zeros to get the required fraction length\n  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);\n\n  let dropTrailingZeros = fractionSize !== 0;\n  // Minimal length = nb of decimals required + current nb of integers\n  // Any number besides that is optional and can be removed if it's a trailing 0\n  const minLen = minFrac + parsedNumber.integerLen;\n  // Do any carrying, e.g. a digit was rounded up to 10\n  const carry = digits.reduceRight(function(carry, d, i, digits) {\n    d = d + carry;\n    digits[i] = d < 10 ? d : d - 10;  // d % 10\n    if (dropTrailingZeros) {\n      // Do not keep meaningless fractional trailing zeros (e.g. 15.52000 --> 15.52)\n      if (digits[i] === 0 && i >= minLen) {\n        digits.pop();\n      } else {\n        dropTrailingZeros = false;\n      }\n    }\n    return d >= 10 ? 1 : 0;  // Math.floor(d / 10);\n  }, 0);\n  if (carry) {\n    digits.unshift(carry);\n    parsedNumber.integerLen++;\n  }\n}\n\nexport function parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"]}