{"version":3,"file":"xhr.js","sourceRoot":"","sources":["../../../../../packages/common/http/src/xhr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpRequest} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpUploadProgressEvent} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n *\n * @stable\n */\nexport abstract class XhrFactory { abstract build(): XMLHttpRequest; }\n\n/**\n * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n *\n * @stable\n */\n@Injectable()\nexport class BrowserXhr implements XhrFactory {\n  constructor() {}\n  build(): any { return <any>(new XMLHttpRequest()); }\n}\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n *\n * @stable\n */\n@Injectable()\nexport class HttpXhrBackend implements HttpBackend {\n  constructor(private xhrFactory: XhrFactory) {}\n\n  /**\n   * Process a request and return a stream of response events.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.urlWithParams);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        const responseType = req.responseType.toLowerCase();\n\n        // JSON responses need to be processed as text. This is because if the server\n        // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n        // xhr.response will be null, and xhr.responseText cannot be accessed to\n        // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n        // is parsed by first requesting text and then applying JSON.parse.\n        xhr.responseType = ((responseType !== 'json') ? responseType : 'text') as any;\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (req.responseType === 'json' && typeof body === 'string') {\n          // Save the original body, before attempting XSSI prefix stripping.\n          const originalBody = body;\n          body = body.replace(XSSI_PREFIX, '');\n          try {\n            // Attempt the parse. If it fails, a parse error should be delivered to the user.\n            body = body !== '' ? JSON.parse(body) : null;\n          } catch (error) {\n            // Since the JSON.parse failed, it's reasonable to assume this might not have been a\n            // JSON response. Restore the original body (including any XSSI prefix) to deliver\n            // a better error response.\n            body = originalBody;\n\n            // If this was an error request to begin with, leave it as a string, it probably\n            // just isn't JSON. Otherwise, deliver the parsing error to the user.\n            if (ok) {\n              // Even though the response status was 2xx, this is still an error.\n              ok = false;\n              // The parse error contains the text of the body that failed to parse.\n              body = { error, text: body } as HttpJsonParseError;\n            }\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const onError = (error: ErrorEvent) => {\n        const res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const onUpProgress = (event: ProgressEvent) => {\n        // Upload progress events are simpler. Begin building the progress\n        // event.\n        let progress: HttpUploadProgressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded: event.loaded,\n        };\n\n        // If the total number of bytes being uploaded is available, include\n        // it.\n        if (event.lengthComputable) {\n          progress.total = event.total;\n        }\n\n        // Send the event.\n        observer.next(progress);\n      };\n\n      // By default, register for load and error events.\n      xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\n}\n"]}