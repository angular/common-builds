{"version":3,"file":"jsonp.js","sourceRoot":"","sources":["../../../../../packages/common/http/src/jsonp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId: number = 0;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nexport abstract class JsonpCallbackContext { [key: string]: (data: any) => void; }\n\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n *\n *\n */\n@Injectable()\nexport class JsonpClientBackend implements HttpBackend {\n  constructor(private callbackMap: JsonpCallbackContext, @Inject(DOCUMENT) private document: any) {}\n\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  private nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n\n  /**\n   * Process a JSONP request and return an event stream of the results.\n   */\n  handle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let body: any|null = null;\n\n      // Whether the response callback has been called.\n      let finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the response is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\n}\n\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n *\n */\n@Injectable()\nexport class JsonpInterceptor {\n  constructor(private jsonp: JsonpClientBackend) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle(req as HttpRequest<never>);\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\n}\n"]}