{"version":3,"file":"common.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/location/navigation_adapter_for_location.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/platform_id.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/viewport_scroller.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/url.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/image_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/cloudflare_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/cloudinary_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/imagekit_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/imgix_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/image_loaders/netlify_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/asserts.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/lcp_image_observer.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/preconnect_link_checker.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/tokens.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/preload-link-creator.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/common/src/directives/ng_optimized_image/ng_optimized_image.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, inject, DestroyRef} from '@angular/core';\nimport {PlatformNavigation} from '../navigation/platform_navigation';\nimport {Location} from './location';\nimport {LocationStrategy} from './location_strategy';\nimport {normalizeQueryParams} from './util';\n\n/**\n * A `Location` implementation that uses the browser's `Navigation` API.\n *\n * This class is an adapter that maps the methods of the `Location` service to the newer\n * browser `Navigation` API. It is used when the `Navigation` API is available.\n *\n * This adapter uses `navigation.navigate()` for `go` and `replaceState` to ensure a single source\n * of truth for the navigation state. The Navigation API's state and `history.state` are separate.\n *\n * Note that `navigation.back()` and `navigation.forward()` can differ from the traditional\n * `history` API in how they traverse the joint session history.\n *\n * @see {@link Location}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API\n */\n@Injectable()\nexport class NavigationAdapterForLocation extends Location {\n  private readonly navigation = inject(PlatformNavigation);\n  private readonly destroyRef = inject(DestroyRef);\n\n  constructor() {\n    super(inject(LocationStrategy));\n\n    this.registerNavigationListeners();\n  }\n\n  private registerNavigationListeners() {\n    const currentEntryChangeListener = () => {\n      this._notifyUrlChangeListeners(this.path(true), this.getState());\n    };\n    this.navigation.addEventListener('currententrychange', currentEntryChangeListener);\n    this.destroyRef.onDestroy(() => {\n      this.navigation.removeEventListener('currententrychange', currentEntryChangeListener);\n    });\n  }\n\n  override getState(): unknown {\n    return this.navigation.currentEntry?.getState();\n  }\n\n  override replaceState(path: string, query: string = '', state: any = null): void {\n    const url = this.prepareExternalUrl(path + normalizeQueryParams(query));\n    // Use navigation API consistently for navigations. The \"navigation API state\"\n    // field has no interaction with the existing \"serialized state\" field, which is what backs history.state\n    this.navigation.navigate(url, {state, history: 'replace'});\n  }\n\n  override go(path: string, query: string = '', state: any = null): void {\n    const url = this.prepareExternalUrl(path + normalizeQueryParams(query));\n    // Use navigation API consistently for navigations. The \"navigation API state\"\n    // field has no interaction with the existing \"serialized state\" field, which is what backs history.state\n    this.navigation.navigate(url, {state, history: 'push'});\n  }\n\n  // Navigation.back/forward differs from history in how it traverses the joint session history\n  // https://github.com/WICG/navigation-api?tab=readme-ov-file#correspondence-with-the-joint-session-history\n  override back() {\n    this.navigation.back();\n  }\n\n  override forward() {\n    this.navigation.forward();\n  }\n\n  override onUrlChange(fn: (url: string, state: unknown) => void): VoidFunction {\n    this._urlChangeListeners.push(fn);\n\n    return () => {\n      const fnIndex = this._urlChangeListeners.indexOf(fn);\n      this._urlChangeListeners.splice(fnIndex, 1);\n    };\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const PLATFORM_BROWSER_ID = 'browser';\nexport const PLATFORM_SERVER_ID = 'server';\n\n/**\n * Returns whether a platform id represents a browser platform.\n * @publicApi\n */\nexport function isPlatformBrowser(platformId: Object): boolean {\n  return platformId === PLATFORM_BROWSER_ID;\n}\n\n/**\n * Returns whether a platform id represents a server platform.\n * @publicApi\n */\nexport function isPlatformServer(platformId: Object): boolean {\n  return platformId === PLATFORM_SERVER_ID;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  inject,\n  ɵɵdefineInjectable,\n  DOCUMENT,\n  ɵformatRuntimeError as formatRuntimeError,\n} from '@angular/core';\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * Defines a scroll position manager. Implemented by `BrowserViewportScroller`.\n *\n * @publicApi\n */\nexport abstract class ViewportScroller {\n  // De-sugared tree-shakable injection\n  // See #23917\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: ViewportScroller,\n    providedIn: 'root',\n    factory: () =>\n      typeof ngServerMode !== 'undefined' && ngServerMode\n        ? new NullViewportScroller()\n        : new BrowserViewportScroller(inject(DOCUMENT), window),\n  });\n\n  /**\n   * Configures the top offset used when scrolling to an anchor.\n   * @param offset A position in screen coordinates (a tuple with x and y values)\n   * or a function that returns the top offset position.\n   *\n   */\n  abstract setOffset(offset: [number, number] | (() => [number, number])): void;\n\n  /**\n   * Retrieves the current scroll position.\n   * @returns A position in screen coordinates (a tuple with x and y values).\n   */\n  abstract getScrollPosition(): [number, number];\n\n  /**\n   * Scrolls to a specified position.\n   * @param position A position in screen coordinates (a tuple with x and y values).\n   */\n  abstract scrollToPosition(position: [number, number], options?: ScrollOptions): void;\n\n  /**\n   * Scrolls to an anchor element.\n   * @param anchor The ID of the anchor element.\n   */\n  abstract scrollToAnchor(anchor: string, options?: ScrollOptions): void;\n\n  /**\n   * Disables automatic scroll restoration provided by the browser.\n   * See also [window.history.scrollRestoration\n   * info](https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration).\n   */\n  abstract setHistoryScrollRestoration(scrollRestoration: 'auto' | 'manual'): void;\n}\n\n/**\n * Manages the scroll position for a browser window.\n */\nexport class BrowserViewportScroller implements ViewportScroller {\n  private offset: () => [number, number] = () => [0, 0];\n\n  constructor(\n    private document: Document,\n    private window: Window,\n  ) {}\n\n  /**\n   * Configures the top offset used when scrolling to an anchor.\n   * @param offset A position in screen coordinates (a tuple with x and y values)\n   * or a function that returns the top offset position.\n   *\n   */\n  setOffset(offset: [number, number] | (() => [number, number])): void {\n    if (Array.isArray(offset)) {\n      this.offset = () => offset;\n    } else {\n      this.offset = offset;\n    }\n  }\n\n  /**\n   * Retrieves the current scroll position.\n   * @returns The position in screen coordinates.\n   */\n  getScrollPosition(): [number, number] {\n    return [this.window.scrollX, this.window.scrollY];\n  }\n\n  /**\n   * Sets the scroll position.\n   * @param position The new position in screen coordinates.\n   */\n  scrollToPosition(position: [number, number], options?: ScrollOptions): void {\n    this.window.scrollTo({...options, left: position[0], top: position[1]});\n  }\n\n  /**\n   * Scrolls to an element and attempts to focus the element.\n   *\n   * Note that the function name here is misleading in that the target string may be an ID for a\n   * non-anchor element.\n   *\n   * @param target The ID of an element or name of the anchor.\n   *\n   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document\n   * @see https://html.spec.whatwg.org/#scroll-to-fragid\n   */\n  scrollToAnchor(target: string, options?: ScrollOptions): void {\n    const elSelected = findAnchorFromDocument(this.document, target);\n\n    if (elSelected) {\n      this.scrollToElement(elSelected, options);\n      // After scrolling to the element, the spec dictates that we follow the focus steps for the\n      // target. Rather than following the robust steps, simply attempt focus.\n      //\n      // @see https://html.spec.whatwg.org/#get-the-focusable-area\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus\n      // @see https://html.spec.whatwg.org/#focusable-area\n      elSelected.focus();\n    }\n  }\n\n  /**\n   * Disables automatic scroll restoration provided by the browser.\n   */\n  setHistoryScrollRestoration(scrollRestoration: 'auto' | 'manual'): void {\n    try {\n      this.window.history.scrollRestoration = scrollRestoration;\n    } catch {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.SCROLL_RESTORATION_UNSUPPORTED,\n          ngDevMode &&\n            'Failed to set `window.history.scrollRestoration`. ' +\n              'This may occur when:\\n' +\n              '• The script is running inside a sandboxed iframe\\n' +\n              '• The window is partially navigated or inactive\\n' +\n              '• The script is executed in an untrusted or special context (e.g., test runners, browser extensions, or content previews)\\n' +\n              'Scroll position may not be preserved across navigation.',\n        ),\n      );\n    }\n  }\n\n  /**\n   * Scrolls to an element using the native offset and the specified offset set on this scroller.\n   *\n   * The offset can be used when we know that there is a floating header and scrolling naively to an\n   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.\n   */\n  private scrollToElement(el: HTMLElement, options?: ScrollOptions): void {\n    const rect = el.getBoundingClientRect();\n    const left = rect.left + this.window.pageXOffset;\n    const top = rect.top + this.window.pageYOffset;\n    const offset = this.offset();\n    this.window.scrollTo({\n      ...options,\n      left: left - offset[0],\n      top: top - offset[1],\n    });\n  }\n}\n\nfunction findAnchorFromDocument(document: Document, target: string): HTMLElement | null {\n  const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];\n\n  if (documentResult) {\n    return documentResult;\n  }\n\n  // `getElementById` and `getElementsByName` won't pierce through the shadow DOM so we\n  // have to traverse the DOM manually and do the lookup through the shadow roots.\n  if (\n    typeof document.createTreeWalker === 'function' &&\n    document.body &&\n    typeof document.body.attachShadow === 'function'\n  ) {\n    const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);\n    let currentNode = treeWalker.currentNode as HTMLElement | null;\n\n    while (currentNode) {\n      const shadowRoot = currentNode.shadowRoot;\n\n      if (shadowRoot) {\n        // Note that `ShadowRoot` doesn't support `getElementsByName`\n        // so we have to fall back to `querySelector`.\n        const result =\n          shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name=\"${target}\"]`);\n        if (result) {\n          return result;\n        }\n      }\n\n      currentNode = treeWalker.nextNode() as HTMLElement | null;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Provides an empty implementation of the viewport scroller.\n */\nexport class NullViewportScroller implements ViewportScroller {\n  /**\n   * Empty implementation\n   */\n  setOffset(offset: [number, number] | (() => [number, number])): void {}\n\n  /**\n   * Empty implementation\n   */\n  getScrollPosition(): [number, number] {\n    return [0, 0];\n  }\n\n  /**\n   * Empty implementation\n   */\n  scrollToPosition(position: [number, number]): void {}\n\n  /**\n   * Empty implementation\n   */\n  scrollToAnchor(anchor: string): void {}\n\n  /**\n   * Empty implementation\n   */\n  setHistoryScrollRestoration(scrollRestoration: 'auto' | 'manual'): void {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Converts a string that represents a URL into a URL class instance.\nexport function getUrl(src: string, win: Window): URL {\n  // Don't use a base URL is the URL is absolute.\n  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);\n}\n\n// Checks whether a URL is absolute (i.e. starts with `http://` or `https://`).\nexport function isAbsoluteUrl(src: string): boolean {\n  return /^https?:\\/\\//.test(src);\n}\n\n// Given a URL, extract the hostname part.\n// If a URL is a relative one - the URL is returned as is.\nexport function extractHostname(url: string): string {\n  return isAbsoluteUrl(url) ? new URL(url).hostname : url;\n}\n\nexport function isValidPath(path: unknown): boolean {\n  const isString = typeof path === 'string';\n\n  if (!isString || path.trim() === '') {\n    return false;\n  }\n\n  // Calling new URL() will throw if the path string is malformed\n  try {\n    const url = new URL(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function normalizePath(path: string): string {\n  return path.endsWith('/') ? path.slice(0, -1) : path;\n}\n\nexport function normalizeSrc(src: string): string {\n  return src.startsWith('/') ? src.slice(1) : src;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, Provider, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../../errors';\nimport {isAbsoluteUrl, isValidPath, normalizePath, normalizeSrc} from '../url';\n\n/**\n * Config options recognized by the image loader function.\n *\n * @see {@link ImageLoader}\n * @see {@link NgOptimizedImage}\n * @publicApi\n */\nexport interface ImageLoaderConfig {\n  /**\n   * Image file name to be added to the image request URL.\n   */\n  src: string;\n  /**\n   * Width of the requested image (to be used when generating srcset).\n   */\n  width?: number;\n  /**\n   * Whether the loader should generate a URL for a small image placeholder instead of a full-sized\n   * image.\n   */\n  isPlaceholder?: boolean;\n  /**\n   * Additional user-provided parameters for use by the ImageLoader.\n   */\n  loaderParams?: {[key: string]: any};\n}\n\n/**\n * Represents an image loader function. Image loader functions are used by the\n * NgOptimizedImage directive to produce full image URL based on the image name and its width.\n *\n * @publicApi\n */\nexport type ImageLoader = (config: ImageLoaderConfig) => string;\n\n/**\n * Noop image loader that does no transformation to the original src and just returns it as is.\n * This loader is used as a default one if more specific logic is not provided in an app config.\n *\n * @see {@link ImageLoader}\n * @see {@link NgOptimizedImage}\n */\nexport const noopImageLoader = (config: ImageLoaderConfig) => config.src;\n\n/**\n * Metadata about the image loader.\n */\nexport type ImageLoaderInfo = {\n  name: string;\n  testUrl: (url: string) => boolean;\n};\n\n/**\n * Injection token that configures the image loader function.\n *\n * @see {@link ImageLoader}\n * @see {@link NgOptimizedImage}\n * @publicApi\n */\nexport const IMAGE_LOADER = new InjectionToken<ImageLoader>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'ImageLoader' : '',\n  {\n    providedIn: 'root',\n    factory: () => noopImageLoader,\n  },\n);\n\n/**\n * Internal helper function that makes it easier to introduce custom image loaders for the\n * `NgOptimizedImage` directive. It is enough to specify a URL builder function to obtain full DI\n * configuration for a given loader: a DI token corresponding to the actual loader function, plus DI\n * tokens managing preconnect check functionality.\n * @param buildUrlFn a function returning a full URL based on loader's configuration\n * @param exampleUrls example of full URLs for a given loader (used in error messages)\n * @returns a set of DI providers corresponding to the configured image loader\n */\nexport function createImageLoader(\n  buildUrlFn: (path: string, config: ImageLoaderConfig) => string,\n  exampleUrls?: string[],\n) {\n  return function provideImageLoader(path: string) {\n    if (!isValidPath(path)) {\n      throwInvalidPathError(path, exampleUrls || []);\n    }\n\n    // The trailing / is stripped (if provided) to make URL construction (concatenation) easier in\n    // the individual loader functions.\n    path = normalizePath(path);\n\n    const loaderFn = (config: ImageLoaderConfig) => {\n      if (isAbsoluteUrl(config.src)) {\n        // Image loader functions expect an image file name (e.g. `my-image.png`)\n        // or a relative path + a file name (e.g. `/a/b/c/my-image.png`) as an input,\n        // so the final absolute URL can be constructed.\n        // When an absolute URL is provided instead - the loader can not\n        // build a final URL, thus the error is thrown to indicate that.\n        throwUnexpectedAbsoluteUrlError(path, config.src);\n      }\n\n      return buildUrlFn(path, {...config, src: normalizeSrc(config.src)});\n    };\n\n    const providers: Provider[] = [{provide: IMAGE_LOADER, useValue: loaderFn}];\n    return providers;\n  };\n}\n\nfunction throwInvalidPathError(path: unknown, exampleUrls: string[]): never {\n  throw new RuntimeError(\n    RuntimeErrorCode.INVALID_LOADER_ARGUMENTS,\n    ngDevMode &&\n      `Image loader has detected an invalid path (\\`${path}\\`). ` +\n        `To fix this, supply a path using one of the following formats: ${exampleUrls.join(\n          ' or ',\n        )}`,\n  );\n}\n\nfunction throwUnexpectedAbsoluteUrlError(path: string, url: string): never {\n  throw new RuntimeError(\n    RuntimeErrorCode.INVALID_LOADER_ARGUMENTS,\n    ngDevMode &&\n      `Image loader has detected a \\`<img>\\` tag with an invalid \\`ngSrc\\` attribute: ${url}. ` +\n        `This image loader expects \\`ngSrc\\` to be a relative URL - ` +\n        `however the provided value is an absolute URL. ` +\n        `To fix this, provide \\`ngSrc\\` as a path relative to the base URL ` +\n        `configured for this loader (\\`${path}\\`).`,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Provider} from '@angular/core';\nimport {PLACEHOLDER_QUALITY} from './constants';\nimport {createImageLoader, ImageLoaderConfig} from './image_loader';\n\n/**\n * Function that generates an ImageLoader for [Cloudflare Image\n * Resizing](https://developers.cloudflare.com/images/image-resizing/) and turns it into an Angular\n * provider. Note: Cloudflare has multiple image products - this provider is specifically for\n * Cloudflare Image Resizing; it will not work with Cloudflare Images or Cloudflare Polish.\n *\n * @param path Your domain name, e.g. https://mysite.com\n * @returns Provider that provides an ImageLoader function\n *\n * @publicApi\n */\nexport const provideCloudflareLoader: (path: string) => Provider[] = createImageLoader(\n  createCloudflareUrl,\n  ngDevMode ? ['https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>'] : undefined,\n);\n\nfunction createCloudflareUrl(path: string, config: ImageLoaderConfig) {\n  let params = `format=auto`;\n  if (config.width) {\n    params += `,width=${config.width}`;\n  }\n\n  // When requesting a placeholder image we ask for a low quality image to reduce the load time.\n  if (config.isPlaceholder) {\n    params += `,quality=${PLACEHOLDER_QUALITY}`;\n  }\n\n  // Cloudflare image URLs format:\n  // https://developers.cloudflare.com/images/image-resizing/url-format/\n  return `${path}/cdn-cgi/image/${params}/${config.src}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Provider} from '@angular/core';\nimport {createImageLoader, ImageLoaderConfig, ImageLoaderInfo} from './image_loader';\n\n/**\n * Name and URL tester for Cloudinary.\n */\nexport const cloudinaryLoaderInfo: ImageLoaderInfo = {\n  name: 'Cloudinary',\n  testUrl: isCloudinaryUrl,\n};\n\nconst CLOUDINARY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.cloudinary\\.com\\/.+/;\n/**\n * Tests whether a URL is from Cloudinary CDN.\n */\nfunction isCloudinaryUrl(url: string): boolean {\n  return CLOUDINARY_LOADER_REGEX.test(url);\n}\n\n/**\n * Function that generates an ImageLoader for Cloudinary and turns it into an Angular provider.\n *\n * @param path Base URL of your Cloudinary images\n * This URL should match one of the following formats:\n * https://res.cloudinary.com/mysite\n * https://mysite.cloudinary.com\n * https://subdomain.mysite.com\n * @returns Set of providers to configure the Cloudinary loader.\n *\n * @publicApi\n */\nexport const provideCloudinaryLoader: (path: string) => Provider[] = createImageLoader(\n  createCloudinaryUrl,\n  ngDevMode\n    ? [\n        'https://res.cloudinary.com/mysite',\n        'https://mysite.cloudinary.com',\n        'https://subdomain.mysite.com',\n      ]\n    : undefined,\n);\n\nfunction createCloudinaryUrl(path: string, config: ImageLoaderConfig) {\n  // Cloudinary image URLformat:\n  // https://cloudinary.com/documentation/image_transformations#transformation_url_structure\n  // Example of a Cloudinary image URL:\n  // https://res.cloudinary.com/mysite/image/upload/c_scale,f_auto,q_auto,w_600/marketing/tile-topics-m.png\n\n  // For a placeholder image, we use the lowest image setting available to reduce the load time\n  // else we use the auto size\n  const quality = config.isPlaceholder ? 'q_auto:low' : 'q_auto';\n\n  let params = `f_auto,${quality}`;\n  if (config.width) {\n    params += `,w_${config.width}`;\n  }\n\n  if (config.loaderParams?.['rounded']) {\n    params += `,r_max`;\n  }\n\n  return `${path}/image/upload/${params}/${config.src}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Provider} from '@angular/core';\nimport {PLACEHOLDER_QUALITY} from './constants';\nimport {createImageLoader, ImageLoaderConfig, ImageLoaderInfo} from './image_loader';\n\n/**\n * Name and URL tester for ImageKit.\n */\nexport const imageKitLoaderInfo: ImageLoaderInfo = {\n  name: 'ImageKit',\n  testUrl: isImageKitUrl,\n};\n\nconst IMAGE_KIT_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imagekit\\.io\\/.+/;\n/**\n * Tests whether a URL is from ImageKit CDN.\n */\nfunction isImageKitUrl(url: string): boolean {\n  return IMAGE_KIT_LOADER_REGEX.test(url);\n}\n\n/**\n * Function that generates an ImageLoader for ImageKit and turns it into an Angular provider.\n *\n * @param path Base URL of your ImageKit images\n * This URL should match one of the following formats:\n * https://ik.imagekit.io/myaccount\n * https://subdomain.mysite.com\n * @returns Set of providers to configure the ImageKit loader.\n *\n * @publicApi\n */\nexport const provideImageKitLoader: (path: string) => Provider[] = createImageLoader(\n  createImagekitUrl,\n  ngDevMode ? ['https://ik.imagekit.io/mysite', 'https://subdomain.mysite.com'] : undefined,\n);\n\nexport function createImagekitUrl(path: string, config: ImageLoaderConfig): string {\n  // Example of an ImageKit image URL:\n  // https://ik.imagekit.io/demo/tr:w-300,h-300/medium_cafe_B1iTdD0C.jpg\n  const {src, width} = config;\n  const params: string[] = [];\n\n  if (width) {\n    params.push(`w-${width}`);\n  }\n\n  // When requesting a placeholder image we ask for a low quality image to reduce the load time.\n  if (config.isPlaceholder) {\n    params.push(`q-${PLACEHOLDER_QUALITY}`);\n  }\n\n  const urlSegments = params.length ? [path, `tr:${params.join(',')}`, src] : [path, src];\n  const url = new URL(urlSegments.join('/'));\n  return url.href;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Provider} from '@angular/core';\nimport {PLACEHOLDER_QUALITY} from './constants';\nimport {createImageLoader, ImageLoaderConfig, ImageLoaderInfo} from './image_loader';\n\n/**\n * Name and URL tester for Imgix.\n */\nexport const imgixLoaderInfo: ImageLoaderInfo = {\n  name: 'Imgix',\n  testUrl: isImgixUrl,\n};\n\nconst IMGIX_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imgix\\.net\\/.+/;\n/**\n * Tests whether a URL is from Imgix CDN.\n */\nfunction isImgixUrl(url: string): boolean {\n  return IMGIX_LOADER_REGEX.test(url);\n}\n\n/**\n * Function that generates an ImageLoader for Imgix and turns it into an Angular provider.\n *\n * @param path path to the desired Imgix origin,\n * e.g. https://somepath.imgix.net or https://images.mysite.com\n * @returns Set of providers to configure the Imgix loader.\n *\n * @publicApi\n */\nexport const provideImgixLoader: (path: string) => Provider[] = createImageLoader(\n  createImgixUrl,\n  ngDevMode ? ['https://somepath.imgix.net/'] : undefined,\n);\n\nfunction createImgixUrl(path: string, config: ImageLoaderConfig) {\n  const url = new URL(`${path}/${config.src}`);\n  // This setting ensures the smallest allowable format is set.\n  url.searchParams.set('auto', 'format');\n  if (config.width) {\n    url.searchParams.set('w', config.width.toString());\n  }\n\n  // When requesting a placeholder image we ask a low quality image to reduce the load time.\n  if (config.isPlaceholder) {\n    url.searchParams.set('q', PLACEHOLDER_QUALITY);\n  }\n  return url.href;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Provider,\n  ɵformatRuntimeError as formatRuntimeError,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../../errors';\nimport {isAbsoluteUrl, isValidPath} from '../url';\n\nimport {IMAGE_LOADER, ImageLoaderConfig, ImageLoaderInfo} from './image_loader';\nimport {PLACEHOLDER_QUALITY} from './constants';\n\n/**\n * Name and URL tester for Netlify.\n */\nexport const netlifyLoaderInfo: ImageLoaderInfo = {\n  name: 'Netlify',\n  testUrl: isNetlifyUrl,\n};\n\nconst NETLIFY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.netlify\\.app\\/.+/;\n\n/**\n * Tests whether a URL is from a Netlify site. This won't catch sites with a custom domain,\n * but it's a good start for sites in development. This is only used to warn users who haven't\n * configured an image loader.\n */\nfunction isNetlifyUrl(url: string): boolean {\n  return NETLIFY_LOADER_REGEX.test(url);\n}\n\n/**\n * Function that generates an ImageLoader for Netlify and turns it into an Angular provider.\n *\n * @param path optional URL of the desired Netlify site. Defaults to the current site.\n * @returns Set of providers to configure the Netlify loader.\n *\n * @publicApi\n */\nexport function provideNetlifyLoader(path?: string) {\n  if (path && !isValidPath(path)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_LOADER_ARGUMENTS,\n      ngDevMode &&\n        `Image loader has detected an invalid path (\\`${path}\\`). ` +\n          `To fix this, supply either the full URL to the Netlify site, or leave it empty to use the current site.`,\n    );\n  }\n\n  if (path) {\n    const url = new URL(path);\n    path = url.origin;\n  }\n\n  const loaderFn = (config: ImageLoaderConfig) => {\n    return createNetlifyUrl(config, path);\n  };\n\n  const providers: Provider[] = [{provide: IMAGE_LOADER, useValue: loaderFn}];\n  return providers;\n}\n\nconst validParams = new Map<string, string>([\n  ['height', 'h'],\n  ['fit', 'fit'],\n  ['quality', 'q'],\n  ['q', 'q'],\n  ['position', 'position'],\n]);\n\nfunction createNetlifyUrl(config: ImageLoaderConfig, path?: string) {\n  // Note: `path` can be undefined, in which case we use a fake one to construct a `URL` instance.\n  const url = new URL(path ?? 'https://a/');\n  url.pathname = '/.netlify/images';\n\n  if (!isAbsoluteUrl(config.src) && !config.src.startsWith('/')) {\n    config.src = '/' + config.src;\n  }\n\n  url.searchParams.set('url', config.src);\n\n  if (config.width) {\n    url.searchParams.set('w', config.width.toString());\n  }\n\n  // When requesting a placeholder image we ask for a low quality image to reduce the load time.\n  // If the quality is specified in the loader config - always use provided value.\n  const configQuality = config.loaderParams?.['quality'] ?? config.loaderParams?.['q'];\n  if (config.isPlaceholder && !configQuality) {\n    url.searchParams.set('q', PLACEHOLDER_QUALITY);\n  }\n\n  for (const [param, value] of Object.entries(config.loaderParams ?? {})) {\n    if (validParams.has(param)) {\n      url.searchParams.set(validParams.get(param)!, value.toString());\n    } else {\n      if (ngDevMode) {\n        console.warn(\n          formatRuntimeError(\n            RuntimeErrorCode.INVALID_LOADER_ARGUMENTS,\n            `The Netlify image loader has detected an \\`<img>\\` tag with the unsupported attribute \"\\`${param}\\`\".`,\n          ),\n        );\n      }\n    }\n  }\n  // The \"a\" hostname is used for relative URLs, so we can remove it from the final URL.\n  return url.hostname === 'a' ? url.href.replace(url.origin, '') : url.href;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\n/**\n * Asserts that the application is in development mode. Throws an error if the application is in\n * production mode. This assert can be used to make sure that there is no dev-mode code invoked in\n * the prod mode accidentally.\n */\nexport function assertDevMode(checkName: string) {\n  if (!ngDevMode) {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNEXPECTED_DEV_MODE_CHECK_IN_PROD_MODE,\n      `Unexpected invocation of the ${checkName} in the prod mode. ` +\n        `Please make sure that the prod mode is enabled for production builds.`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  inject,\n  Injectable,\n  OnDestroy,\n  ɵformatRuntimeError as formatRuntimeError,\n  DOCUMENT,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\nimport {assertDevMode} from './asserts';\nimport {imgDirectiveDetails} from './error_helper';\nimport {getUrl} from './url';\n\ninterface ObservedImageState {\n  priority: boolean;\n  modified: boolean;\n  alreadyWarnedPriority: boolean;\n  alreadyWarnedModified: boolean;\n}\n\n/**\n * Observer that detects whether an image with `NgOptimizedImage`\n * is treated as a Largest Contentful Paint (LCP) element. If so,\n * asserts that the image has the `priority` attribute.\n *\n * Note: this is a dev-mode only class and it does not appear in prod bundles,\n * thus there is no `ngDevMode` use in the code.\n *\n * Based on https://web.dev/lcp/#measure-lcp-in-javascript.\n */\n@Injectable({providedIn: 'root'})\nexport class LCPImageObserver implements OnDestroy {\n  // Map of full image URLs -> original `ngSrc` values.\n  private images = new Map<string, ObservedImageState>();\n\n  private window: Window | null = inject(DOCUMENT).defaultView;\n  private observer: PerformanceObserver | null = null;\n\n  constructor() {\n    assertDevMode('LCP checker');\n\n    if (\n      (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n      typeof PerformanceObserver !== 'undefined'\n    ) {\n      this.observer = this.initPerformanceObserver();\n    }\n  }\n\n  /**\n   * Inits PerformanceObserver and subscribes to LCP events.\n   * Based on https://web.dev/lcp/#measure-lcp-in-javascript\n   */\n  private initPerformanceObserver(): PerformanceObserver {\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      if (entries.length === 0) return;\n      // We use the latest entry produced by the `PerformanceObserver` as the best\n      // signal on which element is actually an LCP one. As an example, the first image to load on\n      // a page, by virtue of being the only thing on the page so far, is often a LCP candidate\n      // and gets reported by PerformanceObserver, but isn't necessarily the LCP element.\n      const lcpElement = entries[entries.length - 1];\n\n      // Cast to `any` due to missing `element` on the `LargestContentfulPaint` type of entry.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/LargestContentfulPaint\n      const imgSrc = (lcpElement as any).element?.src ?? '';\n\n      // Exclude `data:` and `blob:` URLs, since they are not supported by the directive.\n      if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;\n\n      const img = this.images.get(imgSrc);\n      if (!img) return;\n      if (!img.priority && !img.alreadyWarnedPriority) {\n        img.alreadyWarnedPriority = true;\n        logMissingPriorityError(imgSrc);\n      }\n      if (img.modified && !img.alreadyWarnedModified) {\n        img.alreadyWarnedModified = true;\n        logModifiedWarning(imgSrc);\n      }\n    });\n    observer.observe({type: 'largest-contentful-paint', buffered: true});\n    return observer;\n  }\n\n  registerImage(rewrittenSrc: string, originalNgSrc: string, isPriority: boolean) {\n    if (!this.observer) return;\n    const newObservedImageState: ObservedImageState = {\n      priority: isPriority,\n      modified: false,\n      alreadyWarnedModified: false,\n      alreadyWarnedPriority: false,\n    };\n    this.images.set(getUrl(rewrittenSrc, this.window!).href, newObservedImageState);\n  }\n\n  unregisterImage(rewrittenSrc: string) {\n    if (!this.observer) return;\n    this.images.delete(getUrl(rewrittenSrc, this.window!).href);\n  }\n\n  updateImage(originalSrc: string, newSrc: string) {\n    if (!this.observer) return;\n    const originalUrl = getUrl(originalSrc, this.window!).href;\n    const img = this.images.get(originalUrl);\n    if (img) {\n      img.modified = true;\n      this.images.set(getUrl(newSrc, this.window!).href, img);\n      this.images.delete(originalUrl);\n    }\n  }\n\n  ngOnDestroy() {\n    if (!this.observer) return;\n    this.observer.disconnect();\n    this.images.clear();\n  }\n}\n\nfunction logMissingPriorityError(ngSrc: string) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.error(\n    formatRuntimeError(\n      RuntimeErrorCode.LCP_IMG_MISSING_PRIORITY,\n      `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` +\n        `element but was not marked \"priority\". This image should be marked ` +\n        `\"priority\" in order to prioritize its loading. ` +\n        `To fix this, add the \"priority\" attribute.`,\n    ),\n  );\n}\n\nfunction logModifiedWarning(ngSrc: string) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.warn(\n    formatRuntimeError(\n      RuntimeErrorCode.LCP_IMG_NGSRC_MODIFIED,\n      `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` +\n        `element and has had its \"ngSrc\" attribute modified. This can cause ` +\n        `slower loading performance. It is recommended not to modify the \"ngSrc\" ` +\n        `property on any image which could be the LCP element.`,\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  inject,\n  Injectable,\n  InjectionToken,\n  ɵformatRuntimeError as formatRuntimeError,\n  DOCUMENT,\n  OnDestroy,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\nimport {assertDevMode} from './asserts';\nimport {imgDirectiveDetails} from './error_helper';\nimport {extractHostname, getUrl} from './url';\n\n// Set of origins that are always excluded from the preconnect checks.\nconst INTERNAL_PRECONNECT_CHECK_BLOCKLIST = new Set(['localhost', '127.0.0.1', '0.0.0.0', '[::1]']);\n\n/**\n * Injection token to configure which origins should be excluded\n * from the preconnect checks. It can either be a single string or an array of strings\n * to represent a group of origins, for example:\n *\n * ```ts\n *  {provide: PRECONNECT_CHECK_BLOCKLIST, useValue: 'https://your-domain.com'}\n * ```\n *\n * or:\n *\n * ```ts\n *  {provide: PRECONNECT_CHECK_BLOCKLIST,\n *   useValue: ['https://your-domain-1.com', 'https://your-domain-2.com']}\n * ```\n *\n * @publicApi\n */\nexport const PRECONNECT_CHECK_BLOCKLIST = new InjectionToken<Array<string | string[]>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'PRECONNECT_CHECK_BLOCKLIST' : '',\n);\n\n/**\n * Contains the logic to detect whether an image, marked with the \"priority\" attribute\n * has a corresponding `<link rel=\"preconnect\">` tag in the `document.head`.\n *\n * Note: this is a dev-mode only class, which should not appear in prod bundles,\n * thus there is no `ngDevMode` use in the code.\n */\n@Injectable({providedIn: 'root'})\nexport class PreconnectLinkChecker implements OnDestroy {\n  private document = inject(DOCUMENT);\n\n  /**\n   * Set of <link rel=\"preconnect\"> tags found on this page.\n   * The `null` value indicates that there was no DOM query operation performed.\n   */\n  private preconnectLinks: Set<string> | null = null;\n\n  /*\n   * Keep track of all already seen origin URLs to avoid repeating the same check.\n   */\n  private alreadySeen = new Set<string>();\n\n  private window: Window | null = this.document.defaultView;\n\n  private blocklist = new Set<string>(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);\n\n  constructor() {\n    assertDevMode('preconnect link checker');\n    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {optional: true});\n    if (blocklist) {\n      this.populateBlocklist(blocklist);\n    }\n  }\n\n  private populateBlocklist(origins: Array<string | string[]> | string) {\n    if (Array.isArray(origins)) {\n      deepForEach(origins, (origin) => {\n        this.blocklist.add(extractHostname(origin));\n      });\n    } else {\n      this.blocklist.add(extractHostname(origins));\n    }\n  }\n\n  /**\n   * Checks that a preconnect resource hint exists in the head for the\n   * given src.\n   *\n   * @param rewrittenSrc src formatted with loader\n   * @param originalNgSrc ngSrc value\n   */\n  assertPreconnect(rewrittenSrc: string, originalNgSrc: string): void {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) return;\n\n    const imgUrl = getUrl(rewrittenSrc, this.window!);\n    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;\n\n    // Register this origin as seen, so we don't check it again later.\n    this.alreadySeen.add(imgUrl.origin);\n\n    // Note: we query for preconnect links only *once* and cache the results\n    // for the entire lifespan of an application, since it's unlikely that the\n    // list would change frequently. This allows to make sure there are no\n    // performance implications of making extra DOM lookups for each image.\n    this.preconnectLinks ??= this.queryPreconnectLinks();\n\n    if (!this.preconnectLinks.has(imgUrl.origin)) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.PRIORITY_IMG_MISSING_PRECONNECT_TAG,\n          `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this ` +\n            `image. Preconnecting to the origin(s) that serve priority images ensures that these ` +\n            `images are delivered as soon as possible. To fix this, please add the following ` +\n            `element into the <head> of the document:\\n` +\n            `  <link rel=\"preconnect\" href=\"${imgUrl.origin}\">`,\n        ),\n      );\n    }\n  }\n\n  private queryPreconnectLinks(): Set<string> {\n    const preconnectUrls = new Set<string>();\n    const links = this.document.querySelectorAll<HTMLLinkElement>('link[rel=preconnect]');\n    for (const link of links) {\n      const url = getUrl(link.href, this.window!);\n      preconnectUrls.add(url.origin);\n    }\n    return preconnectUrls;\n  }\n\n  ngOnDestroy() {\n    this.preconnectLinks?.clear();\n    this.alreadySeen.clear();\n  }\n}\n\n/**\n * Invokes a callback for each element in the array. Also invokes a callback\n * recursively for each nested array.\n */\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  for (let value of input) {\n    Array.isArray(value) ? deepForEach(value, fn) : fn(value);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * In SSR scenarios, a preload `<link>` element is generated for priority images.\n * Having a large number of preload tags may negatively affect the performance,\n * so we warn developers (by throwing an error) if the number of preloaded images\n * is above a certain threshold. This const specifies this threshold.\n */\nexport const DEFAULT_PRELOADED_IMAGES_LIMIT = 5;\n\n/**\n * Helps to keep track of priority images that already have a corresponding\n * preload tag (to avoid generating multiple preload tags with the same URL).\n *\n * This Set tracks the original src passed into the `ngSrc` input not the src after it has been\n * run through the specified `IMAGE_LOADER`.\n */\nexport const PRELOADED_IMAGES = new InjectionToken<Set<string>>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'NG_OPTIMIZED_PRELOADED_IMAGES' : '',\n  {\n    providedIn: 'root',\n    factory: () => new Set<string>(),\n  },\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  inject,\n  Injectable,\n  Renderer2,\n  ɵformatRuntimeError as formatRuntimeError,\n  DOCUMENT,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\nimport {DEFAULT_PRELOADED_IMAGES_LIMIT, PRELOADED_IMAGES} from './tokens';\n\n/**\n * @description Contains the logic needed to track and add preload link tags to the `<head>` tag. It\n * will also track what images have already had preload link tags added so as to not duplicate link\n * tags.\n *\n * In dev mode this service will validate that the number of preloaded images does not exceed the\n * configured default preloaded images limit: {@link DEFAULT_PRELOADED_IMAGES_LIMIT}.\n */\n@Injectable({providedIn: 'root'})\nexport class PreloadLinkCreator {\n  private readonly preloadedImages = inject(PRELOADED_IMAGES);\n  private readonly document = inject(DOCUMENT);\n  private errorShown = false;\n\n  /**\n   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the\n   * server while using Angular Universal and SSR to kick off image loads for high priority images.\n   *\n   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)\n   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`\n   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from\n   * the CDN.\n   *\n   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}\n   *\n   * @param renderer The `Renderer2` passed in from the directive\n   * @param src The original src of the image that is set on the `ngSrc` input.\n   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input\n   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag\n   */\n  createPreloadLinkTag(renderer: Renderer2, src: string, srcset?: string, sizes?: string): void {\n    if (\n      ngDevMode &&\n      !this.errorShown &&\n      this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT\n    ) {\n      this.errorShown = true;\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.TOO_MANY_PRELOADED_IMAGES,\n          `The \\`NgOptimizedImage\\` directive has detected that more than ` +\n            `${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. ` +\n            `This might negatively affect an overall performance of the page. ` +\n            `To fix this, remove the \"priority\" attribute from images with less priority.`,\n        ),\n      );\n    }\n\n    if (this.preloadedImages.has(src)) {\n      return;\n    }\n\n    this.preloadedImages.add(src);\n\n    const preload = renderer.createElement('link');\n    renderer.setAttribute(preload, 'as', 'image');\n    renderer.setAttribute(preload, 'href', src);\n    renderer.setAttribute(preload, 'rel', 'preload');\n    renderer.setAttribute(preload, 'fetchpriority', 'high');\n\n    if (sizes) {\n      renderer.setAttribute(preload, 'imageSizes', sizes);\n    }\n\n    if (srcset) {\n      renderer.setAttribute(preload, 'imageSrcset', srcset);\n    }\n\n    renderer.appendChild(this.document.head, preload);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ApplicationRef,\n  booleanAttribute,\n  ChangeDetectorRef,\n  DestroyRef,\n  Directive,\n  ElementRef,\n  ɵformatRuntimeError as formatRuntimeError,\n  ɵIMAGE_CONFIG as IMAGE_CONFIG,\n  ɵIMAGE_CONFIG_DEFAULTS as IMAGE_CONFIG_DEFAULTS,\n  ɵImageConfig as ImageConfig,\n  inject,\n  Injector,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnChanges,\n  OnInit,\n  ɵperformanceMarkFeature as performanceMarkFeature,\n  Renderer2,\n  ɵRuntimeError as RuntimeError,\n  ɵSafeValue as SafeValue,\n  SimpleChanges,\n  ɵunwrapSafeValue as unwrapSafeValue,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\nimport {imgDirectiveDetails} from './error_helper';\nimport {cloudinaryLoaderInfo} from './image_loaders/cloudinary_loader';\nimport {\n  IMAGE_LOADER,\n  ImageLoader,\n  ImageLoaderConfig,\n  noopImageLoader,\n} from './image_loaders/image_loader';\nimport {imageKitLoaderInfo} from './image_loaders/imagekit_loader';\nimport {imgixLoaderInfo} from './image_loaders/imgix_loader';\nimport {netlifyLoaderInfo} from './image_loaders/netlify_loader';\nimport {LCPImageObserver} from './lcp_image_observer';\nimport {PreconnectLinkChecker} from './preconnect_link_checker';\nimport {PreloadLinkCreator} from './preload-link-creator';\n\n/**\n * When a Base64-encoded image is passed as an input to the `NgOptimizedImage` directive,\n * an error is thrown. The image content (as a string) might be very long, thus making\n * it hard to read an error message if the entire string is included. This const defines\n * the number of characters that should be included into the error message. The rest\n * of the content is truncated.\n */\nconst BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;\n\n/**\n * RegExpr to determine whether a src in a srcset is using width descriptors.\n * Should match something like: \"100w, 200w\".\n */\nconst VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\\s*\\d+w\\s*(,|$)){1,})$/;\n\n/**\n * RegExpr to determine whether a src in a srcset is using density descriptors.\n * Should match something like: \"1x, 2x, 50x\". Also supports decimals like \"1.5x, 1.50x\".\n */\nconst VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\\s*\\d+(\\.\\d+)?x\\s*(,|$)){1,})$/;\n\n/**\n * Srcset values with a density descriptor higher than this value will actively\n * throw an error. Such densities are not permitted as they cause image sizes\n * to be unreasonably large and slow down LCP.\n */\nexport const ABSOLUTE_SRCSET_DENSITY_CAP = 3;\n\n/**\n * Used only in error message text to communicate best practices, as we will\n * only throw based on the slightly more conservative ABSOLUTE_SRCSET_DENSITY_CAP.\n */\nexport const RECOMMENDED_SRCSET_DENSITY_CAP = 2;\n\n/**\n * Used in generating automatic density-based srcsets\n */\nconst DENSITY_SRCSET_MULTIPLIERS = [1, 2];\n\n/**\n * Used to determine which breakpoints to use on full-width images\n */\nconst VIEWPORT_BREAKPOINT_CUTOFF = 640;\n/**\n * Used to determine whether two aspect ratios are similar in value.\n */\nconst ASPECT_RATIO_TOLERANCE = 0.1;\n\n/**\n * Used to determine whether the image has been requested at an overly\n * large size compared to the actual rendered image size (after taking\n * into account a typical device pixel ratio). In pixels.\n */\nconst OVERSIZED_IMAGE_TOLERANCE = 1000;\n\n/**\n * Used to limit automatic srcset generation of very large sources for\n * fixed-size images. In pixels.\n */\nconst FIXED_SRCSET_WIDTH_LIMIT = 1920;\nconst FIXED_SRCSET_HEIGHT_LIMIT = 1080;\n\n/**\n * Placeholder dimension (height or width) limit in pixels. Angular produces a warning\n * when this limit is crossed.\n */\nconst PLACEHOLDER_DIMENSION_LIMIT = 1000;\n\n/**\n * Used to warn or error when the user provides an overly large dataURL for the placeholder\n * attribute.\n * Character count of Base64 images is 1 character per byte, and base64 encoding is approximately\n * 33% larger than base images, so 4000 characters is around 3KB on disk and 10000 characters is\n * around 7.7KB. Experimentally, 4000 characters is about 20x20px in PNG or medium-quality JPEG\n * format, and 10,000 is around 50x50px, but there's quite a bit of variation depending on how the\n * image is saved.\n */\nexport const DATA_URL_WARN_LIMIT = 4000;\nexport const DATA_URL_ERROR_LIMIT = 10000;\n\n/** Info about built-in loaders we can test for. */\nexport const BUILT_IN_LOADERS = [\n  imgixLoaderInfo,\n  imageKitLoaderInfo,\n  cloudinaryLoaderInfo,\n  netlifyLoaderInfo,\n];\n\n/**\n * Threshold for the PRIORITY_TRUE_COUNT\n */\nconst PRIORITY_COUNT_THRESHOLD = 10;\n\n/**\n * This count is used to log a devMode warning\n * when the count of directive instances with priority=true\n * exceeds the threshold PRIORITY_COUNT_THRESHOLD\n */\nlet IMGS_WITH_PRIORITY_ATTR_COUNT = 0;\n\n/**\n * This function is for testing purpose.\n */\nexport function resetImagePriorityCount() {\n  IMGS_WITH_PRIORITY_ATTR_COUNT = 0;\n}\n\n/**\n * Config options used in rendering placeholder images.\n *\n * @see {@link NgOptimizedImage}\n * @publicApi\n */\nexport interface ImagePlaceholderConfig {\n  blur?: boolean;\n}\n\n/**\n * Directive that improves image loading performance by enforcing best practices.\n *\n * `NgOptimizedImage` ensures that the loading of the Largest Contentful Paint (LCP) image is\n * prioritized by:\n * - Automatically setting the `fetchpriority` attribute on the `<img>` tag\n * - Lazy loading non-priority images by default\n * - Automatically generating a preconnect link tag in the document head\n *\n * In addition, the directive:\n * - Generates appropriate asset URLs if a corresponding `ImageLoader` function is provided\n * - Automatically generates a srcset\n * - Requires that `width` and `height` are set\n * - Warns if `width` or `height` have been set incorrectly\n * - Warns if the image will be visually distorted when rendered\n *\n * @usageNotes\n * The `NgOptimizedImage` directive is marked as [standalone](guide/components/importing) and can\n * be imported directly.\n *\n * Follow the steps below to enable and use the directive:\n * 1. Import it into the necessary NgModule or a standalone Component.\n * 2. Optionally provide an `ImageLoader` if you use an image hosting service.\n * 3. Update the necessary `<img>` tags in templates and replace `src` attributes with `ngSrc`.\n * Using a `ngSrc` allows the directive to control when the `src` gets set, which triggers an image\n * download.\n *\n * Step 1: import the `NgOptimizedImage` directive.\n *\n * ```ts\n * import { NgOptimizedImage } from '@angular/common';\n *\n * // Include it into the necessary NgModule\n * @NgModule({\n *   imports: [NgOptimizedImage],\n * })\n * class AppModule {}\n *\n * // ... or a standalone Component\n * @Component({\n *   imports: [NgOptimizedImage],\n * })\n * class MyStandaloneComponent {}\n * ```\n *\n * Step 2: configure a loader.\n *\n * To use the **default loader**: no additional code changes are necessary. The URL returned by the\n * generic loader will always match the value of \"src\". In other words, this loader applies no\n * transformations to the resource URL and the value of the `ngSrc` attribute will be used as is.\n *\n * To use an existing loader for a **third-party image service**: add the provider factory for your\n * chosen service to the `providers` array. In the example below, the Imgix loader is used:\n *\n * ```ts\n * import {provideImgixLoader} from '@angular/common';\n *\n * // Call the function and add the result to the `providers` array:\n * providers: [\n *   provideImgixLoader(\"https://my.base.url/\"),\n * ],\n * ```\n *\n * The `NgOptimizedImage` directive provides the following functions:\n * - `provideCloudflareLoader`\n * - `provideCloudinaryLoader`\n * - `provideImageKitLoader`\n * - `provideImgixLoader`\n *\n * If you use a different image provider, you can create a custom loader function as described\n * below.\n *\n * To use a **custom loader**: provide your loader function as a value for the `IMAGE_LOADER` DI\n * token.\n *\n * ```ts\n * import {IMAGE_LOADER, ImageLoaderConfig} from '@angular/common';\n *\n * // Configure the loader using the `IMAGE_LOADER` token.\n * providers: [\n *   {\n *      provide: IMAGE_LOADER,\n *      useValue: (config: ImageLoaderConfig) => {\n *        return `https://example.com/${config.src}-${config.width}.jpg`;\n *      }\n *   },\n * ],\n * ```\n *\n * Step 3: update `<img>` tags in templates to use `ngSrc` instead of `src`.\n *\n * ```html\n * <img ngSrc=\"logo.png\" width=\"200\" height=\"100\">\n * ```\n *\n * @publicApi\n * @see [Image Optimization Guide](guide/image-optimization)\n */\n@Directive({\n  selector: 'img[ngSrc]',\n  host: {\n    '[style.position]': 'fill ? \"absolute\" : null',\n    '[style.width]': 'fill ? \"100%\" : null',\n    '[style.height]': 'fill ? \"100%\" : null',\n    '[style.inset]': 'fill ? \"0\" : null',\n    '[style.background-size]': 'placeholder ? \"cover\" : null',\n    '[style.background-position]': 'placeholder ? \"50% 50%\" : null',\n    '[style.background-repeat]': 'placeholder ? \"no-repeat\" : null',\n    '[style.background-image]': 'placeholder ? generatePlaceholder(placeholder) : null',\n    '[style.filter]':\n      'placeholder && shouldBlurPlaceholder(placeholderConfig) ? \"blur(15px)\" : null',\n  },\n})\nexport class NgOptimizedImage implements OnInit, OnChanges {\n  private imageLoader = inject(IMAGE_LOADER);\n  private config: ImageConfig = processConfig(inject(IMAGE_CONFIG));\n  private renderer = inject(Renderer2);\n  private imgElement: HTMLImageElement = inject(ElementRef).nativeElement;\n  private injector = inject(Injector);\n\n  // An LCP image observer should be injected only in development mode.\n  // Do not assign it to `null` to avoid having a redundant property in the production bundle.\n  private lcpObserver?: LCPImageObserver;\n\n  /**\n   * Calculate the rewritten `src` once and store it.\n   * This is needed to avoid repetitive calculations and make sure the directive cleanup in the\n   * `ngOnDestroy` does not rely on the `IMAGE_LOADER` logic (which in turn can rely on some other\n   * instance that might be already destroyed).\n   */\n  private _renderedSrc: string | null = null;\n\n  /**\n   * Name of the source image.\n   * Image name will be processed by the image loader and the final URL will be applied as the `src`\n   * property of the image.\n   */\n  @Input({required: true, transform: unwrapSafeUrl}) ngSrc!: string;\n\n  /**\n   * A comma separated list of width or density descriptors.\n   * The image name will be taken from `ngSrc` and combined with the list of width or density\n   * descriptors to generate the final `srcset` property of the image.\n   *\n   * Example:\n   * ```html\n   * <img ngSrc=\"hello.jpg\" ngSrcset=\"100w, 200w\" />  =>\n   * <img src=\"path/hello.jpg\" srcset=\"path/hello.jpg?w=100 100w, path/hello.jpg?w=200 200w\" />\n   * ```\n   */\n  @Input() ngSrcset!: string;\n\n  /**\n   * The base `sizes` attribute passed through to the `<img>` element.\n   * Providing sizes causes the image to create an automatic responsive srcset.\n   */\n  @Input() sizes?: string;\n\n  /**\n   * For responsive images: the intrinsic width of the image in pixels.\n   * For fixed size images: the desired rendered width of the image in pixels.\n   */\n  @Input({transform: numberAttribute}) width: number | undefined;\n\n  /**\n   * For responsive images: the intrinsic height of the image in pixels.\n   * For fixed size images: the desired rendered height of the image in pixels.\n   */\n  @Input({transform: numberAttribute}) height: number | undefined;\n\n  /**\n   * The desired decoding behavior for the image. Defaults to `auto`\n   * if not explicitly set, matching native browser behavior.\n   *\n   * Use `async` to decode the image off the main thread (non-blocking),\n   * `sync` for immediate decoding (blocking), or `auto` to let the\n   * browser decide the optimal strategy.\n   *\n   * [Spec](https://html.spec.whatwg.org/multipage/images.html#image-decoding-hint)\n   */\n  @Input() decoding?: 'sync' | 'async' | 'auto';\n\n  /**\n   * The desired loading behavior (lazy, eager, or auto). Defaults to `lazy`,\n   * which is recommended for most images.\n   *\n   * Warning: Setting images as loading=\"eager\" or loading=\"auto\" marks them\n   * as non-priority images and can hurt loading performance. For images which\n   * may be the LCP element, use the `priority` attribute instead of `loading`.\n   */\n  @Input() loading?: 'lazy' | 'eager' | 'auto';\n\n  /**\n   * Indicates whether this image should have a high priority.\n   */\n  @Input({transform: booleanAttribute}) priority = false;\n\n  /**\n   * Data to pass through to custom loaders.\n   */\n  @Input() loaderParams?: {[key: string]: any};\n\n  /**\n   * Disables automatic srcset generation for this image.\n   */\n  @Input({transform: booleanAttribute}) disableOptimizedSrcset = false;\n\n  /**\n   * Sets the image to \"fill mode\", which eliminates the height/width requirement and adds\n   * styles such that the image fills its containing element.\n   */\n  @Input({transform: booleanAttribute}) fill = false;\n\n  /**\n   * A URL or data URL for an image to be used as a placeholder while this image loads.\n   */\n  @Input({transform: booleanOrUrlAttribute}) placeholder?: string | boolean;\n\n  /**\n   * Configuration object for placeholder settings. Options:\n   *   * blur: Setting this to false disables the automatic CSS blur.\n   */\n  @Input() placeholderConfig?: ImagePlaceholderConfig;\n\n  /**\n   * Value of the `src` attribute if set on the host `<img>` element.\n   * This input is exclusively read to assert that `src` is not set in conflict\n   * with `ngSrc` and that images don't start to load until a lazy loading strategy is set.\n   * @internal\n   */\n  @Input() src?: string;\n\n  /**\n   * Value of the `srcset` attribute if set on the host `<img>` element.\n   * This input is exclusively read to assert that `srcset` is not set in conflict\n   * with `ngSrcset` and that images don't start to load until a lazy loading strategy is set.\n   * @internal\n   */\n  @Input() srcset?: string;\n\n  constructor() {\n    if (ngDevMode) {\n      this.lcpObserver = this.injector.get(LCPImageObserver);\n\n      // Using `DestroyRef` to avoid having an empty `ngOnDestroy` method since this\n      // is only run in development mode.\n      const destroyRef = inject(DestroyRef);\n      destroyRef.onDestroy(() => {\n        if (!this.priority && this._renderedSrc !== null) {\n          this.lcpObserver!.unregisterImage(this._renderedSrc);\n        }\n      });\n    }\n  }\n\n  /** @docs-private */\n  ngOnInit() {\n    performanceMarkFeature('NgOptimizedImage');\n\n    if (ngDevMode) {\n      const ngZone = this.injector.get(NgZone);\n      assertNonEmptyInput(this, 'ngSrc', this.ngSrc);\n      assertValidNgSrcset(this, this.ngSrcset);\n      assertNoConflictingSrc(this);\n      if (this.ngSrcset) {\n        assertNoConflictingSrcset(this);\n      }\n      assertNotBase64Image(this);\n      assertNotBlobUrl(this);\n      if (this.fill) {\n        assertEmptyWidthAndHeight(this);\n        // This leaves the Angular zone to avoid triggering unnecessary change detection cycles when\n        // `load` tasks are invoked on images.\n        ngZone.runOutsideAngular(() =>\n          assertNonZeroRenderedHeight(this, this.imgElement, this.renderer),\n        );\n      } else {\n        assertNonEmptyWidthAndHeight(this);\n        if (this.height !== undefined) {\n          assertGreaterThanZero(this, this.height, 'height');\n        }\n        if (this.width !== undefined) {\n          assertGreaterThanZero(this, this.width, 'width');\n        }\n        // Only check for distorted images when not in fill mode, where\n        // images may be intentionally stretched, cropped or letterboxed.\n        ngZone.runOutsideAngular(() =>\n          assertNoImageDistortion(this, this.imgElement, this.renderer),\n        );\n      }\n      assertValidLoadingInput(this);\n      assertValidDecodingInput(this);\n      if (!this.ngSrcset) {\n        assertNoComplexSizes(this);\n      }\n      assertValidPlaceholder(this, this.imageLoader);\n      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);\n      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);\n      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);\n\n      ngZone.runOutsideAngular(() => {\n        this.lcpObserver!.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);\n      });\n\n      if (this.priority) {\n        const checker = this.injector.get(PreconnectLinkChecker);\n        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);\n\n        if (typeof ngServerMode !== 'undefined' && !ngServerMode) {\n          const applicationRef = this.injector.get(ApplicationRef);\n          assetPriorityCountBelowThreshold(applicationRef);\n        }\n      }\n    }\n    if (this.placeholder) {\n      this.removePlaceholderOnLoad(this.imgElement);\n    }\n    this.setHostAttributes();\n  }\n\n  private setHostAttributes() {\n    // Must set width/height explicitly in case they are bound (in which case they will\n    // only be reflected and not found by the browser)\n    if (this.fill) {\n      this.sizes ||= '100vw';\n    } else {\n      this.setHostAttribute('width', this.width!.toString());\n      this.setHostAttribute('height', this.height!.toString());\n    }\n\n    this.setHostAttribute('loading', this.getLoadingBehavior());\n    this.setHostAttribute('fetchpriority', this.getFetchPriority());\n    this.setHostAttribute('decoding', this.getDecoding());\n\n    // The `data-ng-img` attribute flags an image as using the directive, to allow\n    // for analysis of the directive's performance.\n    this.setHostAttribute('ng-img', 'true');\n\n    // The `src` and `srcset` attributes should be set last since other attributes\n    // could affect the image's loading behavior.\n    const rewrittenSrcset = this.updateSrcAndSrcset();\n\n    if (this.sizes) {\n      if (this.getLoadingBehavior() === 'lazy') {\n        this.setHostAttribute('sizes', 'auto, ' + this.sizes);\n      } else {\n        this.setHostAttribute('sizes', this.sizes);\n      }\n    } else {\n      if (\n        this.ngSrcset &&\n        VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) &&\n        this.getLoadingBehavior() === 'lazy'\n      ) {\n        this.setHostAttribute('sizes', 'auto, 100vw');\n      }\n    }\n\n    if (typeof ngServerMode !== 'undefined' && ngServerMode && this.priority) {\n      const preloadLinkCreator = this.injector.get(PreloadLinkCreator);\n      preloadLinkCreator.createPreloadLinkTag(\n        this.renderer,\n        this.getRewrittenSrc(),\n        rewrittenSrcset,\n        this.sizes,\n      );\n    }\n  }\n\n  /** @docs-private */\n  ngOnChanges(changes: SimpleChanges) {\n    if (ngDevMode) {\n      assertNoPostInitInputChange(this, changes, [\n        'ngSrcset',\n        'width',\n        'height',\n        'priority',\n        'fill',\n        'loading',\n        'sizes',\n        'loaderParams',\n        'disableOptimizedSrcset',\n      ]);\n    }\n    if (changes['ngSrc'] && !changes['ngSrc'].isFirstChange()) {\n      const oldSrc = this._renderedSrc;\n      this.updateSrcAndSrcset(true);\n\n      if (ngDevMode) {\n        const newSrc = this._renderedSrc;\n        if (oldSrc && newSrc && oldSrc !== newSrc) {\n          const ngZone = this.injector.get(NgZone);\n          ngZone.runOutsideAngular(() => {\n            this.lcpObserver!.updateImage(oldSrc, newSrc);\n          });\n        }\n      }\n    }\n\n    if (\n      ngDevMode &&\n      changes['placeholder']?.currentValue &&\n      typeof ngServerMode !== 'undefined' &&\n      !ngServerMode\n    ) {\n      assertPlaceholderDimensions(this, this.imgElement);\n    }\n  }\n\n  private callImageLoader(\n    configWithoutCustomParams: Omit<ImageLoaderConfig, 'loaderParams'>,\n  ): string {\n    let augmentedConfig: ImageLoaderConfig = configWithoutCustomParams;\n    if (this.loaderParams) {\n      augmentedConfig.loaderParams = this.loaderParams;\n    }\n    return this.imageLoader(augmentedConfig);\n  }\n\n  private getLoadingBehavior(): string {\n    if (!this.priority && this.loading !== undefined) {\n      return this.loading;\n    }\n    return this.priority ? 'eager' : 'lazy';\n  }\n\n  private getFetchPriority(): string {\n    return this.priority ? 'high' : 'auto';\n  }\n\n  private getDecoding(): string {\n    if (this.priority) {\n      // `sync` means the image is decoded immediately when it's loaded,\n      // reducing the risk of content shifting later (important for LCP).\n      // If we're marking an image as priority, we want it decoded and\n      // painted as early as possible.\n      return 'sync';\n    }\n    // Returns the value of the `decoding` attribute, defaulting to `auto`\n    // if not explicitly provided. This mimics native browser behavior and\n    // avoids breaking changes when no decoding strategy is specified.\n    return this.decoding ?? 'auto';\n  }\n\n  private getRewrittenSrc(): string {\n    // ImageLoaderConfig supports setting a width property. However, we're not setting width here\n    // because if the developer uses rendered width instead of intrinsic width in the HTML width\n    // attribute, the image requested may be too small for 2x+ screens.\n    if (!this._renderedSrc) {\n      const imgConfig = {src: this.ngSrc};\n      // Cache calculated image src to reuse it later in the code.\n      this._renderedSrc = this.callImageLoader(imgConfig);\n    }\n    return this._renderedSrc;\n  }\n\n  private getRewrittenSrcset(): string {\n    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);\n    const finalSrcs = this.ngSrcset\n      .split(',')\n      .filter((src) => src !== '')\n      .map((srcStr) => {\n        srcStr = srcStr.trim();\n        const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width!;\n        return `${this.callImageLoader({src: this.ngSrc, width})} ${srcStr}`;\n      });\n    return finalSrcs.join(', ');\n  }\n\n  private getAutomaticSrcset(): string {\n    if (this.sizes) {\n      return this.getResponsiveSrcset();\n    } else {\n      return this.getFixedSrcset();\n    }\n  }\n\n  private getResponsiveSrcset(): string {\n    const {breakpoints} = this.config;\n\n    let filteredBreakpoints = breakpoints!;\n    if (this.sizes?.trim() === '100vw') {\n      // Since this is a full-screen-width image, our srcset only needs to include\n      // breakpoints with full viewport widths.\n      filteredBreakpoints = breakpoints!.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);\n    }\n\n    const finalSrcs = filteredBreakpoints.map(\n      (bp) => `${this.callImageLoader({src: this.ngSrc, width: bp})} ${bp}w`,\n    );\n    return finalSrcs.join(', ');\n  }\n\n  private updateSrcAndSrcset(forceSrcRecalc = false): string | undefined {\n    if (forceSrcRecalc) {\n      // Reset cached value, so that the followup `getRewrittenSrc()` call\n      // will recalculate it and update the cache.\n      this._renderedSrc = null;\n    }\n\n    const rewrittenSrc = this.getRewrittenSrc();\n    this.setHostAttribute('src', rewrittenSrc);\n\n    let rewrittenSrcset: string | undefined = undefined;\n    if (this.ngSrcset) {\n      rewrittenSrcset = this.getRewrittenSrcset();\n    } else if (this.shouldGenerateAutomaticSrcset()) {\n      rewrittenSrcset = this.getAutomaticSrcset();\n    }\n\n    if (rewrittenSrcset) {\n      this.setHostAttribute('srcset', rewrittenSrcset);\n    }\n    return rewrittenSrcset;\n  }\n\n  private getFixedSrcset(): string {\n    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map(\n      (multiplier) =>\n        `${this.callImageLoader({\n          src: this.ngSrc,\n          width: this.width! * multiplier,\n        })} ${multiplier}x`,\n    );\n    return finalSrcs.join(', ');\n  }\n\n  private shouldGenerateAutomaticSrcset(): boolean {\n    let oversizedImage = false;\n    if (!this.sizes) {\n      oversizedImage =\n        this.width! > FIXED_SRCSET_WIDTH_LIMIT || this.height! > FIXED_SRCSET_HEIGHT_LIMIT;\n    }\n    return (\n      !this.disableOptimizedSrcset &&\n      !this.srcset &&\n      this.imageLoader !== noopImageLoader &&\n      !oversizedImage\n    );\n  }\n\n  /**\n   * Returns an image url formatted for use with the CSS background-image property. Expects one of:\n   * * A base64 encoded image, which is wrapped and passed through.\n   * * A boolean. If true, calls the image loader to generate a small placeholder url.\n   */\n  protected generatePlaceholder(placeholderInput: string | boolean): string | boolean | null {\n    const {placeholderResolution} = this.config;\n    if (placeholderInput === true) {\n      return `url(${this.callImageLoader({\n        src: this.ngSrc,\n        width: placeholderResolution,\n        isPlaceholder: true,\n      })})`;\n    } else if (typeof placeholderInput === 'string') {\n      return `url(${placeholderInput})`;\n    }\n    return null;\n  }\n\n  /**\n   * Determines if blur should be applied, based on an optional boolean\n   * property `blur` within the optional configuration object `placeholderConfig`.\n   */\n  protected shouldBlurPlaceholder(placeholderConfig?: ImagePlaceholderConfig): boolean {\n    if (!placeholderConfig || !placeholderConfig.hasOwnProperty('blur')) {\n      return true;\n    }\n    return Boolean(placeholderConfig.blur);\n  }\n\n  private removePlaceholderOnLoad(img: HTMLImageElement): void {\n    const callback = () => {\n      const changeDetectorRef = this.injector.get(ChangeDetectorRef);\n      removeLoadListenerFn();\n      removeErrorListenerFn();\n      this.placeholder = false;\n      changeDetectorRef.markForCheck();\n    };\n\n    const removeLoadListenerFn = this.renderer.listen(img, 'load', callback);\n    const removeErrorListenerFn = this.renderer.listen(img, 'error', callback);\n\n    callOnLoadIfImageIsLoaded(img, callback);\n  }\n\n  private setHostAttribute(name: string, value: string): void {\n    this.renderer.setAttribute(this.imgElement, name, value);\n  }\n}\n\n/***** Helpers *****/\n\n/**\n * Sorts provided config breakpoints and uses defaults.\n */\nfunction processConfig(config: ImageConfig): ImageConfig {\n  let sortedBreakpoints: {breakpoints?: number[]} = {};\n  if (config.breakpoints) {\n    sortedBreakpoints.breakpoints = config.breakpoints.sort((a, b) => a - b);\n  }\n  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config, sortedBreakpoints);\n}\n\n/***** Assert functions *****/\n\n/**\n * Verifies that there is no `src` set on a host element.\n */\nfunction assertNoConflictingSrc(dir: NgOptimizedImage) {\n  if (dir.src) {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNEXPECTED_SRC_ATTR,\n      `${imgDirectiveDetails(dir.ngSrc)} both \\`src\\` and \\`ngSrc\\` have been set. ` +\n        `Supplying both of these attributes breaks lazy loading. ` +\n        `The NgOptimizedImage directive sets \\`src\\` itself based on the value of \\`ngSrc\\`. ` +\n        `To fix this, please remove the \\`src\\` attribute.`,\n    );\n  }\n}\n\n/**\n * Verifies that there is no `srcset` set on a host element.\n */\nfunction assertNoConflictingSrcset(dir: NgOptimizedImage) {\n  if (dir.srcset) {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNEXPECTED_SRCSET_ATTR,\n      `${imgDirectiveDetails(dir.ngSrc)} both \\`srcset\\` and \\`ngSrcset\\` have been set. ` +\n        `Supplying both of these attributes breaks lazy loading. ` +\n        `The NgOptimizedImage directive sets \\`srcset\\` itself based on the value of ` +\n        `\\`ngSrcset\\`. To fix this, please remove the \\`srcset\\` attribute.`,\n    );\n  }\n}\n\n/**\n * Verifies that the `ngSrc` is not a Base64-encoded image.\n */\nfunction assertNotBase64Image(dir: NgOptimizedImage) {\n  let ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith('data:')) {\n    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {\n      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + '...';\n    }\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc, false)} \\`ngSrc\\` is a Base64-encoded string ` +\n        `(${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. ` +\n        `To fix this, disable the NgOptimizedImage directive for this element ` +\n        `by removing \\`ngSrc\\` and using a standard \\`src\\` attribute instead.`,\n    );\n  }\n}\n\n/**\n * Verifies that the 'sizes' only includes responsive values.\n */\nfunction assertNoComplexSizes(dir: NgOptimizedImage) {\n  let sizes = dir.sizes;\n  if (sizes?.match(/((\\)|,)\\s|^)\\d+px/)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc, false)} \\`sizes\\` was set to a string including ` +\n        `pixel values. For automatic \\`srcset\\` generation, \\`sizes\\` must only include responsive ` +\n        `values, such as \\`sizes=\"50vw\"\\` or \\`sizes=\"(min-width: 768px) 50vw, 100vw\"\\`. ` +\n        `To fix this, modify the \\`sizes\\` attribute, or provide your own \\`ngSrcset\\` value directly.`,\n    );\n  }\n}\n\nfunction assertValidPlaceholder(dir: NgOptimizedImage, imageLoader: ImageLoader) {\n  assertNoPlaceholderConfigWithoutPlaceholder(dir);\n  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);\n  assertNoOversizedDataUrl(dir);\n}\n\n/**\n * Verifies that placeholderConfig isn't being used without placeholder\n */\nfunction assertNoPlaceholderConfigWithoutPlaceholder(dir: NgOptimizedImage) {\n  if (dir.placeholderConfig && !dir.placeholder) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(\n        dir.ngSrc,\n        false,\n      )} \\`placeholderConfig\\` options were provided for an ` +\n        `image that does not use the \\`placeholder\\` attribute, and will have no effect.`,\n    );\n  }\n}\n\n/**\n * Warns if a relative URL placeholder is specified, but no loader is present to provide the small\n * image.\n */\nfunction assertNoRelativePlaceholderWithoutLoader(dir: NgOptimizedImage, imageLoader: ImageLoader) {\n  if (dir.placeholder === true && imageLoader === noopImageLoader) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_NECESSARY_LOADER,\n      `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to true but ` +\n        `no image loader is configured (i.e. the default one is being used), ` +\n        `which would result in the same image being used for the primary image and its placeholder. ` +\n        `To fix this, provide a loader or remove the \\`placeholder\\` attribute from the image.`,\n    );\n  }\n}\n\n/**\n * Warns or throws an error if an oversized dataURL placeholder is provided.\n */\nfunction assertNoOversizedDataUrl(dir: NgOptimizedImage) {\n  if (\n    dir.placeholder &&\n    typeof dir.placeholder === 'string' &&\n    dir.placeholder.startsWith('data:')\n  ) {\n    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {\n      throw new RuntimeError(\n        RuntimeErrorCode.OVERSIZED_PLACEHOLDER,\n        `${imgDirectiveDetails(\n          dir.ngSrc,\n        )} the \\`placeholder\\` attribute is set to a data URL which is longer ` +\n          `than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders ` +\n          `directly increase the bundle size of Angular and hurt page load performance. To fix this, generate ` +\n          `a smaller data URL placeholder.`,\n      );\n    }\n    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.OVERSIZED_PLACEHOLDER,\n          `${imgDirectiveDetails(\n            dir.ngSrc,\n          )} the \\`placeholder\\` attribute is set to a data URL which is longer ` +\n            `than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders ` +\n            `directly increase the bundle size of Angular and hurt page load performance. For better loading performance, ` +\n            `generate a smaller data URL placeholder.`,\n        ),\n      );\n    }\n  }\n}\n\n/**\n * Verifies that the `ngSrc` is not a Blob URL.\n */\nfunction assertNotBlobUrl(dir: NgOptimizedImage) {\n  const ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith('blob:')) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrc\\` was set to a blob URL (${ngSrc}). ` +\n        `Blob URLs are not supported by the NgOptimizedImage directive. ` +\n        `To fix this, disable the NgOptimizedImage directive for this element ` +\n        `by removing \\`ngSrc\\` and using a regular \\`src\\` attribute instead.`,\n    );\n  }\n}\n\n/**\n * Verifies that the input is set to a non-empty string.\n */\nfunction assertNonEmptyInput(dir: NgOptimizedImage, name: string, value: unknown) {\n  const isString = typeof value === 'string';\n  const isEmptyString = isString && value.trim() === '';\n  if (!isString || isEmptyString) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} \\`${name}\\` has an invalid value ` +\n        `(\\`${value}\\`). To fix this, change the value to a non-empty string.`,\n    );\n  }\n}\n\n/**\n * Verifies that the `ngSrcset` is in a valid format, e.g. \"100w, 200w\" or \"1x, 2x\".\n */\nexport function assertValidNgSrcset(dir: NgOptimizedImage, value: unknown) {\n  if (value == null) return;\n  assertNonEmptyInput(dir, 'ngSrcset', value);\n  const stringVal = value as string;\n  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);\n  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);\n\n  if (isValidDensityDescriptor) {\n    assertUnderDensityCap(dir, stringVal);\n  }\n\n  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;\n  if (!isValidSrcset) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrcset\\` has an invalid value (\\`${value}\\`). ` +\n        `To fix this, supply \\`ngSrcset\\` using a comma-separated list of one or more width ` +\n        `descriptors (e.g. \"100w, 200w\") or density descriptors (e.g. \"1x, 2x\").`,\n    );\n  }\n}\n\nfunction assertUnderDensityCap(dir: NgOptimizedImage, value: string) {\n  const underDensityCap = value\n    .split(',')\n    .every((num) => num === '' || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);\n  if (!underDensityCap) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` contains an unsupported image density:` +\n        `\\`${value}\\`. NgOptimizedImage generally recommends a max image density of ` +\n        `${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ` +\n        `${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities ` +\n        `greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for ` +\n        `most use cases. Images that will be pinch-zoomed are typically the primary use case for ` +\n        `${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`,\n    );\n  }\n}\n\n/**\n * Creates a `RuntimeError` instance to represent a situation when an input is set after\n * the directive has initialized.\n */\nfunction postInitInputChangeError(dir: NgOptimizedImage, inputName: string): {} {\n  let reason!: string;\n  if (inputName === 'width' || inputName === 'height') {\n    reason =\n      `Changing \\`${inputName}\\` may result in different attribute value ` +\n      `applied to the underlying image element and cause layout shifts on a page.`;\n  } else {\n    reason =\n      `Changing the \\`${inputName}\\` would have no effect on the underlying ` +\n      `image element, because the resource loading has already occurred.`;\n  }\n  return new RuntimeError(\n    RuntimeErrorCode.UNEXPECTED_INPUT_CHANGE,\n    `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` was updated after initialization. ` +\n      `The NgOptimizedImage directive will not react to this input change. ${reason} ` +\n      `To fix this, either switch \\`${inputName}\\` to a static value ` +\n      `or wrap the image element in an @if that is gated on the necessary value.`,\n  );\n}\n\n/**\n * Verify that none of the listed inputs has changed.\n */\nfunction assertNoPostInitInputChange(\n  dir: NgOptimizedImage,\n  changes: SimpleChanges,\n  inputs: string[],\n) {\n  inputs.forEach((input) => {\n    const isUpdated = changes.hasOwnProperty(input);\n    if (isUpdated && !changes[input].isFirstChange()) {\n      if (input === 'ngSrc') {\n        // When the `ngSrc` input changes, we detect that only in the\n        // `ngOnChanges` hook, thus the `ngSrc` is already set. We use\n        // `ngSrc` in the error message, so we use a previous value, but\n        // not the updated one in it.\n        dir = {ngSrc: changes[input].previousValue} as NgOptimizedImage;\n      }\n      throw postInitInputChangeError(dir, input);\n    }\n  });\n}\n\n/**\n * Verifies that a specified input is a number greater than 0.\n */\nfunction assertGreaterThanZero(dir: NgOptimizedImage, inputValue: unknown, inputName: string) {\n  const validNumber = typeof inputValue === 'number' && inputValue > 0;\n  const validString =\n    typeof inputValue === 'string' && /^\\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;\n  if (!validNumber && !validString) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` has an invalid value. ` +\n        `To fix this, provide \\`${inputName}\\` as a number greater than 0.`,\n    );\n  }\n}\n\n/**\n * Verifies that the rendered image is not visually distorted. Effectively this is checking:\n * - Whether the \"width\" and \"height\" attributes reflect the actual dimensions of the image.\n * - Whether image styling is \"correct\" (see below for a longer explanation).\n */\nfunction assertNoImageDistortion(\n  dir: NgOptimizedImage,\n  img: HTMLImageElement,\n  renderer: Renderer2,\n) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const computedStyle = window.getComputedStyle(img);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n    const boxSizing = computedStyle.getPropertyValue('box-sizing');\n\n    if (boxSizing === 'border-box') {\n      const paddingTop = computedStyle.getPropertyValue('padding-top');\n      const paddingRight = computedStyle.getPropertyValue('padding-right');\n      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');\n      const paddingLeft = computedStyle.getPropertyValue('padding-left');\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n\n    const renderedAspectRatio = renderedWidth / renderedHeight;\n    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;\n\n    const intrinsicWidth = img.naturalWidth;\n    const intrinsicHeight = img.naturalHeight;\n    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;\n\n    const suppliedWidth = dir.width!;\n    const suppliedHeight = dir.height!;\n    const suppliedAspectRatio = suppliedWidth / suppliedHeight;\n\n    // Tolerance is used to account for the impact of subpixel rendering.\n    // Due to subpixel rendering, the rendered, intrinsic, and supplied\n    // aspect ratios of a correctly configured image may not exactly match.\n    // For example, a `width=4030 height=3020` image might have a rendered\n    // size of \"1062w, 796.48h\". (An aspect ratio of 1.334... vs. 1.333...)\n    const inaccurateDimensions =\n      Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;\n    const stylingDistortion =\n      nonZeroRenderedDimensions &&\n      Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;\n\n    if (inaccurateDimensions) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.INVALID_INPUT,\n          `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match ` +\n            `the aspect ratio indicated by the width and height attributes. ` +\n            `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` +\n            `(aspect-ratio: ${round(\n              intrinsicAspectRatio,\n            )}). \\nSupplied width and height attributes: ` +\n            `${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(\n              suppliedAspectRatio,\n            )}). ` +\n            `\\nTo fix this, update the width and height attributes.`,\n        ),\n      );\n    } else if (stylingDistortion) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.INVALID_INPUT,\n          `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image ` +\n            `does not match the image's intrinsic aspect ratio. ` +\n            `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` +\n            `(aspect-ratio: ${round(intrinsicAspectRatio)}). \\nRendered image size: ` +\n            `${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ` +\n            `${round(renderedAspectRatio)}). \\nThis issue can occur if \"width\" and \"height\" ` +\n            `attributes are added to an image without updating the corresponding ` +\n            `image styling. To fix this, adjust image styling. In most cases, ` +\n            `adding \"height: auto\" or \"width: auto\" to the image styling will fix ` +\n            `this issue.`,\n        ),\n      );\n    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {\n      // If `ngSrcset` hasn't been set, sanity check the intrinsic size.\n      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;\n      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;\n      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n      if (oversizedWidth || oversizedHeight) {\n        console.warn(\n          formatRuntimeError(\n            RuntimeErrorCode.OVERSIZED_IMAGE,\n            `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly ` +\n              `larger than necessary. ` +\n              `\\nRendered image size: ${renderedWidth}w x ${renderedHeight}h. ` +\n              `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. ` +\n              `\\nRecommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. ` +\n              `\\nNote: Recommended intrinsic image size is calculated assuming a maximum DPR of ` +\n              `${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image ` +\n              `or consider using the \"ngSrcset\" and \"sizes\" attributes.`,\n          ),\n        );\n      }\n    }\n  };\n\n  const removeLoadListenerFn = renderer.listen(img, 'load', callback);\n\n  // We only listen to the `error` event to remove the `load` event listener because it will not be\n  // fired if the image fails to load. This is done to prevent memory leaks in development mode\n  // because image elements aren't garbage-collected properly. It happens because zone.js stores the\n  // event listener directly on the element and closures capture `dir`.\n  const removeErrorListenerFn = renderer.listen(img, 'error', () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n\n  callOnLoadIfImageIsLoaded(img, callback);\n}\n\n/**\n * Verifies that a specified input is set.\n */\nfunction assertNonEmptyWidthAndHeight(dir: NgOptimizedImage) {\n  let missingAttributes = [];\n  if (dir.width === undefined) missingAttributes.push('width');\n  if (dir.height === undefined) missingAttributes.push('height');\n  if (missingAttributes.length > 0) {\n    throw new RuntimeError(\n      RuntimeErrorCode.REQUIRED_INPUT_MISSING,\n      `${imgDirectiveDetails(dir.ngSrc)} these required attributes ` +\n        `are missing: ${missingAttributes.map((attr) => `\"${attr}\"`).join(', ')}. ` +\n        `Including \"width\" and \"height\" attributes will prevent image-related layout shifts. ` +\n        `To fix this, include \"width\" and \"height\" attributes on the image tag or turn on ` +\n        `\"fill\" mode with the \\`fill\\` attribute.`,\n    );\n  }\n}\n\n/**\n * Verifies that width and height are not set. Used in fill mode, where those attributes don't make\n * sense.\n */\nfunction assertEmptyWidthAndHeight(dir: NgOptimizedImage) {\n  if (dir.width || dir.height) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} the attributes \\`height\\` and/or \\`width\\` are present ` +\n        `along with the \\`fill\\` attribute. Because \\`fill\\` mode causes an image to fill its containing ` +\n        `element, the size attributes have no effect and should be removed.`,\n    );\n  }\n}\n\n/**\n * Verifies that the rendered image has a nonzero height. If the image is in fill mode, provides\n * guidance that this can be caused by the containing element's CSS position property.\n */\nfunction assertNonZeroRenderedHeight(\n  dir: NgOptimizedImage,\n  img: HTMLImageElement,\n  renderer: Renderer2,\n) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const renderedHeight = img.clientHeight;\n    if (dir.fill && renderedHeight === 0) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.INVALID_INPUT,\n          `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. ` +\n            `This is likely because the containing element does not have the CSS 'position' ` +\n            `property set to one of the following: \"relative\", \"fixed\", or \"absolute\". ` +\n            `To fix this problem, make sure the container element has the CSS 'position' ` +\n            `property defined and the height of the element is not zero.`,\n        ),\n      );\n    }\n  };\n\n  const removeLoadListenerFn = renderer.listen(img, 'load', callback);\n\n  // See comments in the `assertNoImageDistortion`.\n  const removeErrorListenerFn = renderer.listen(img, 'error', () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n\n  callOnLoadIfImageIsLoaded(img, callback);\n}\n\n/**\n * Verifies that the `loading` attribute is set to a valid input &\n * is not used on priority images.\n */\nfunction assertValidLoadingInput(dir: NgOptimizedImage) {\n  if (dir.loading && dir.priority) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute ` +\n        `was used on an image that was marked \"priority\". ` +\n        `Setting \\`loading\\` on priority images is not allowed ` +\n        `because these images will always be eagerly loaded. ` +\n        `To fix this, remove the “loading” attribute from the priority image.`,\n    );\n  }\n  const validInputs = ['auto', 'eager', 'lazy'];\n  if (typeof dir.loading === 'string' && !validInputs.includes(dir.loading)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute ` +\n        `has an invalid value (\\`${dir.loading}\\`). ` +\n        `To fix this, provide a valid value (\"lazy\", \"eager\", or \"auto\").`,\n    );\n  }\n}\n\n/**\n * Verifies that the `decoding` attribute is set to a valid input.\n */\nfunction assertValidDecodingInput(dir: NgOptimizedImage) {\n  const validInputs = ['sync', 'async', 'auto'];\n  if (typeof dir.decoding === 'string' && !validInputs.includes(dir.decoding)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INPUT,\n      `${imgDirectiveDetails(dir.ngSrc)} the \\`decoding\\` attribute ` +\n        `has an invalid value (\\`${dir.decoding}\\`). ` +\n        `To fix this, provide a valid value (\"sync\", \"async\", or \"auto\").`,\n    );\n  }\n}\n\n/**\n * Warns if NOT using a loader (falling back to the generic loader) and\n * the image appears to be hosted on one of the image CDNs for which\n * we do have a built-in image loader. Suggests switching to the\n * built-in loader.\n *\n * @param ngSrc Value of the ngSrc attribute\n * @param imageLoader ImageLoader provided\n */\nfunction assertNotMissingBuiltInLoader(ngSrc: string, imageLoader: ImageLoader) {\n  if (imageLoader === noopImageLoader) {\n    let builtInLoaderName = '';\n    for (const loader of BUILT_IN_LOADERS) {\n      if (loader.testUrl(ngSrc)) {\n        builtInLoaderName = loader.name;\n        break;\n      }\n    }\n    if (builtInLoaderName) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.MISSING_BUILTIN_LOADER,\n          `NgOptimizedImage: It looks like your images may be hosted on the ` +\n            `${builtInLoaderName} CDN, but your app is not using Angular's ` +\n            `built-in loader for that CDN. We recommend switching to use ` +\n            `the built-in by calling \\`provide${builtInLoaderName}Loader()\\` ` +\n            `in your \\`providers\\` and passing it your instance's base URL. ` +\n            `If you don't want to use the built-in loader, define a custom ` +\n            `loader function using IMAGE_LOADER to silence this warning.`,\n        ),\n      );\n    }\n  }\n}\n\n/**\n * Warns if ngSrcset is present and no loader is configured (i.e. the default one is being used).\n */\nfunction assertNoNgSrcsetWithoutLoader(dir: NgOptimizedImage, imageLoader: ImageLoader) {\n  if (dir.ngSrcset && imageLoader === noopImageLoader) {\n    console.warn(\n      formatRuntimeError(\n        RuntimeErrorCode.MISSING_NECESSARY_LOADER,\n        `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` attribute is present but ` +\n          `no image loader is configured (i.e. the default one is being used), ` +\n          `which would result in the same image being used for all configured sizes. ` +\n          `To fix this, provide a loader or remove the \\`ngSrcset\\` attribute from the image.`,\n      ),\n    );\n  }\n}\n\n/**\n * Warns if loaderParams is present and no loader is configured (i.e. the default one is being\n * used).\n */\nfunction assertNoLoaderParamsWithoutLoader(dir: NgOptimizedImage, imageLoader: ImageLoader) {\n  if (dir.loaderParams && imageLoader === noopImageLoader) {\n    console.warn(\n      formatRuntimeError(\n        RuntimeErrorCode.MISSING_NECESSARY_LOADER,\n        `${imgDirectiveDetails(dir.ngSrc)} the \\`loaderParams\\` attribute is present but ` +\n          `no image loader is configured (i.e. the default one is being used), ` +\n          `which means that the loaderParams data will not be consumed and will not affect the URL. ` +\n          `To fix this, provide a custom loader or remove the \\`loaderParams\\` attribute from the image.`,\n      ),\n    );\n  }\n}\n\n/**\n * Warns if the priority attribute is used too often on page load\n */\nasync function assetPriorityCountBelowThreshold(appRef: ApplicationRef) {\n  if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {\n    IMGS_WITH_PRIORITY_ATTR_COUNT++;\n    await appRef.whenStable();\n    if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {\n      console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.TOO_MANY_PRIORITY_ATTRIBUTES,\n          `NgOptimizedImage: The \"priority\" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). ` +\n            `Marking too many images as \"high\" priority can hurt your application's LCP (https://web.dev/lcp). ` +\n            `\"Priority\" should only be set on the image expected to be the page's LCP element.`,\n        ),\n      );\n    }\n  } else {\n    IMGS_WITH_PRIORITY_ATTR_COUNT++;\n  }\n}\n\n/**\n * Warns if placeholder's dimension are over a threshold.\n *\n * This assert function is meant to only run on the browser.\n */\nfunction assertPlaceholderDimensions(dir: NgOptimizedImage, imgElement: HTMLImageElement) {\n  const computedStyle = window.getComputedStyle(imgElement);\n  let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n  let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n\n  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {\n    console.warn(\n      formatRuntimeError(\n        RuntimeErrorCode.PLACEHOLDER_DIMENSION_LIMIT_EXCEEDED,\n        `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one ` +\n          `of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. ` +\n          `To fix this, use a smaller image as a placeholder.`,\n      ),\n    );\n  }\n}\n\nfunction callOnLoadIfImageIsLoaded(img: HTMLImageElement, callback: VoidFunction): void {\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-img-complete\n  // The spec defines that `complete` is truthy once its request state is fully available.\n  // The image may already be available if it’s loaded from the browser cache.\n  // In that case, the `load` event will not fire at all, meaning that all setup\n  // callbacks listening for the `load` event will not be invoked.\n  // In Safari, there is a known behavior where the `complete` property of an\n  // `HTMLImageElement` may sometimes return `true` even when the image is not fully loaded.\n  // Checking both `img.complete` and `img.naturalWidth` is the most reliable way to\n  // determine if an image has been fully loaded, especially in browsers where the\n  // `complete` property may return `true` prematurely.\n  if (img.complete && img.naturalWidth) {\n    callback();\n  }\n}\n\nfunction round(input: number): number | string {\n  return Number.isInteger(input) ? input : input.toFixed(2);\n}\n\n// Transform function to handle SafeValue input for ngSrc. This doesn't do any sanitization,\n// as that is not needed for img.src and img.srcset. This transform is purely for compatibility.\nfunction unwrapSafeUrl(value: string | SafeValue): string {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return unwrapSafeValue(value);\n}\n\n// Transform function to handle inputs which may be booleans, strings, or string representations\n// of boolean values. Used for the placeholder attribute.\nexport function booleanOrUrlAttribute(value: boolean | string): boolean | string {\n  if (typeof value === 'string' && value !== 'true' && value !== 'false' && value !== '') {\n    return value;\n  }\n  return booleanAttribute(value);\n}\n"],"names":["registerNavigationListeners","currentEntryChangeListener","_notifyUrlChangeListeners","path","getState","navigation","addEventListener","destroyRef","onDestroy","replaceState","query","state","url","prepareExternalUrl","normalizeQueryParams","navigate","history","back","forward","PLATFORM_BROWSER_ID","isPlatformBrowser","platformId","isPlatformServer","ViewportScroller","providedIn","factory","ngServerMode","NullViewportScroller","BrowserViewportScroller","inject","DOCUMENT","window","getScrollPosition","position","options","scrollTo","left","top","elSelected","focus","scrollToElement","el","rect","getBoundingClientRect","offset","findAnchorFromDocument","document","target","getElementById","getElementsByName","isAbsoluteUrl","src","test","extractHostname","URL","hostname","isValidPath","isString","noopImageLoader","config","IMAGE_LOADER","InjectionToken","ngDevMode","undefined","isPlaceholder","testUrl","isCloudinaryUrl","CLOUDINARY_LOADER_REGEX","createCloudinaryUrl","quality","name","isImageKitUrl","IMAGE_KIT_LOADER_REGEX","width","params","push","isImgixUrl","IMGIX_LOADER_REGEX","netlifyLoaderInfo","isNetlifyUrl","NETLIFY_LOADER_REGEX","origin","providers","provide","useValue","loaderFn","validParams","Map","createNetlifyUrl","set","searchParams","toString","assertDevMode","checkName","observer","initPerformanceObserver","PerformanceObserver","entryList","entries","length","lcpElement","imgSrc","element","startsWith","img","images","get","priority","alreadyWarnedPriority","logMissingPriorityError","modified","alreadyWarnedModified","logModifiedWarning","observe","type","buffered","registerImage","rewrittenSrc","originalNgSrc","isPriority","newObservedImageState","href","updateImage","originalSrc","newSrc","originalUrl","getUrl","delete","ngOnDestroy","INTERNAL_PRECONNECT_CHECK_BLOCKLIST","Set","PreconnectLinkChecker","preconnectLinks","constructor","origins","blocklist","add","assertPreconnect","imgUrl","queryPreconnectLinks","has","deepForEach","input","fn","DEFAULT_PRELOADED_IMAGES_LIMIT","PRELOADED_IMAGES","BASE64_IMG_MAX_LENGTH_IN_ERROR","ABSOLUTE_SRCSET_DENSITY_CAP","ASPECT_RATIO_TOLERANCE","OVERSIZED_IMAGE_TOLERANCE","FIXED_SRCSET_HEIGHT_LIMIT","lcpObserver","_renderedSrc","disableOptimizedSrcset","srcset","unregisterImage","ngZone","injector","NgZone","assertNonEmptyInput","ngSrc","runOutsideAngular","assertNonZeroRenderedHeight","imgElement","renderer","height","assertNoImageDistortion","ngSrcset","assertNoComplexSizes","imageLoader","assertNotMissingBuiltInLoader","assertNoLoaderParamsWithoutLoader","getRewrittenSrc","applicationRef","ApplicationRef","assetPriorityCountBelowThreshold","removePlaceholderOnLoad","fill","setHostAttribute","getLoadingBehavior","getFetchPriority","getDecoding","rewrittenSrcset","updateSrcAndSrcset","sizes","VALID_WIDTH_DESCRIPTOR_SRCSET","PreloadLinkCreator","ngOnChanges","changes","isFirstChange","oldSrc","currentValue","callImageLoader","configWithoutCustomParams","augmentedConfig","loaderParams","loading","decoding","imgConfig","getRewrittenSrcset","widthSrcSet","finalSrcs","split","filter","map","srcStr","trim","parseFloat","getAutomaticSrcset","getFixedSrcset","DENSITY_SRCSET_MULTIPLIERS","multiplier","join","shouldGenerateAutomaticSrcset","oversizedImage","FIXED_SRCSET_WIDTH_LIMIT","placeholderResolution","placeholderInput","shouldBlurPlaceholder","placeholderConfig","hasOwnProperty","callback","changeDetectorRef","ChangeDetectorRef","removeLoadListenerFn","removeErrorListenerFn","placeholder","value","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","NgOptimizedImage","deps","ɵɵFactoryTarget","Directive","ɵdir","ɵɵngDeclareDirective","isStandalone","selector","inputs","unwrapSafeUrl","numberAttribute","booleanAttribute","booleanOrUrlAttribute","host","properties","usesOnChanges","args","ctorParameters","propDecorators","Input","transform","breakpoints","sort","a","b","assertNoConflictingSrcset","dir","RuntimeError","imgDirectiveDetails","assertNotBase64Image","assertValidPlaceholder","assertNoPlaceholderConfigWithoutPlaceholder","assertNoRelativePlaceholderWithoutLoader","assertNoOversizedDataUrl","DATA_URL_ERROR_LIMIT","console","warn","formatRuntimeError","DATA_URL_WARN_LIMIT","assertNotBlobUrl","assertValidNgSrcset","isValidSrcset","isValidWidthDescriptor","assertUnderDensityCap","underDensityCap","num","RECOMMENDED_SRCSET_DENSITY_CAP","postInitInputChangeError","inputName","reason","isUpdated","assertGreaterThanZero","inputValue","validNumber","validString","parseInt","getPropertyValue","boxSizing","paddingTop","computedStyle","paddingRight","renderedWidth","paddingLeft","paddingBottom","renderedHeight","nonZeroRenderedDimensions","naturalWidth","naturalHeight","intrinsicWidth","intrinsicHeight","suppliedHeight","suppliedAspectRatio","suppliedWidth","Math","abs","intrinsicAspectRatio","stylingDistortion","renderedAspectRatio","round","recommendedWidth","recommendedHeight","oversizedWidth","oversizedHeight","listen","callOnLoadIfImageIsLoaded","assertNonEmptyWidthAndHeight","missingAttributes"],"mappings":"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"}