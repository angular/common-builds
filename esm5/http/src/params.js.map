{"version":3,"file":"params.js","sourceRoot":"","sources":["../../../../../../packages/common/http/src/params.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A codec for encoding and decoding parameters in URLs.\n *\n * Used by `HttpParams`.\n *\n *\n **/\nexport interface HttpParameterCodec {\n  encodeKey(key: string): string;\n  encodeValue(value: string): string;\n\n  decodeKey(key: string): string;\n  decodeValue(value: string): string;\n}\n\n/**\n * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n * serialize and parse URL parameter keys and values.\n *\n *\n */\nexport class HttpUrlEncodingCodec implements HttpParameterCodec {\n  encodeKey(k: string): string { return standardEncoding(k); }\n\n  encodeValue(v: string): string { return standardEncoding(v); }\n\n  decodeKey(k: string): string { return decodeURIComponent(k); }\n\n  decodeValue(v: string) { return decodeURIComponent(v); }\n}\n\n\nfunction paramParser(rawParams: string, codec: HttpParameterCodec): Map<string, string[]> {\n  const map = new Map<string, string[]>();\n  if (rawParams.length > 0) {\n    const params: string[] = rawParams.split('&');\n    params.forEach((param: string) => {\n      const eqIdx = param.indexOf('=');\n      const [key, val]: string[] = eqIdx == -1 ?\n          [codec.decodeKey(param), ''] :\n          [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\nfunction standardEncoding(v: string): string {\n  return encodeURIComponent(v)\n      .replace(/%40/gi, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/gi, '$')\n      .replace(/%2C/gi, ',')\n      .replace(/%3B/gi, ';')\n      .replace(/%2B/gi, '+')\n      .replace(/%3D/gi, '=')\n      .replace(/%3F/gi, '?')\n      .replace(/%2F/gi, '/');\n}\n\ninterface Update {\n  param: string;\n  value?: string;\n  op: 'a'|'d'|'s';\n}\n\n/** Options used to construct an `HttpParams` instance. */\nexport interface HttpParamsOptions {\n  /**\n   * String representation of the HTTP params in URL-query-string format. Mutually exclusive with\n   * `fromObject`.\n   */\n  fromString?: string;\n\n  /** Object map of the HTTP params. Mutally exclusive with `fromString`. */\n  fromObject?: {[param: string]: string | string[]};\n\n  /** Encoding codec used to parse and serialize the params. */\n  encoder?: HttpParameterCodec;\n}\n\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable - all mutation operations return a new instance.\n *\n *\n */\nexport class HttpParams {\n  private map: Map<string, string[]>|null;\n  private encoder: HttpParameterCodec;\n  private updates: Update[]|null = null;\n  private cloneFrom: HttpParams|null = null;\n\n  constructor(options: HttpParamsOptions = {} as HttpParamsOptions) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    if (!!options.fromString) {\n      if (!!options.fromObject) {\n        throw new Error(`Cannot specify both fromString and fromObject.`);\n      }\n      this.map = paramParser(options.fromString, this.encoder);\n    } else if (!!options.fromObject) {\n      this.map = new Map<string, string[]>();\n      Object.keys(options.fromObject).forEach(key => {\n        const value = (options.fromObject as any)[key];\n        this.map !.set(key, Array.isArray(value) ? value : [value]);\n      });\n    } else {\n      this.map = null;\n    }\n  }\n\n  /**\n   * Check whether the body has one or more values for the given parameter name.\n   */\n  has(param: string): boolean {\n    this.init();\n    return this.map !.has(param);\n  }\n\n  /**\n   * Get the first value for the given parameter name, or `null` if it's not present.\n   */\n  get(param: string): string|null {\n    this.init();\n    const res = this.map !.get(param);\n    return !!res ? res[0] : null;\n  }\n\n  /**\n   * Get all values for the given parameter name, or `null` if it's not present.\n   */\n  getAll(param: string): string[]|null {\n    this.init();\n    return this.map !.get(param) || null;\n  }\n\n  /**\n   * Get all the parameter names for this body.\n   */\n  keys(): string[] {\n    this.init();\n    return Array.from(this.map !.keys());\n  }\n\n  /**\n   * Construct a new body with an appended value for the given parameter name.\n   */\n  append(param: string, value: string): HttpParams { return this.clone({param, value, op: 'a'}); }\n\n  /**\n   * Construct a new body with a new value for the given parameter name.\n   */\n  set(param: string, value: string): HttpParams { return this.clone({param, value, op: 's'}); }\n\n  /**\n   * Construct a new body with either the given value for the given parameter\n   * removed, if a value is given, or all values for the given parameter removed\n   * if not.\n   */\n  delete (param: string, value?: string): HttpParams { return this.clone({param, value, op: 'd'}); }\n\n  /**\n   * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are\n   * separated by `&`s.\n   */\n  toString(): string {\n    this.init();\n    return this.keys()\n        .map(key => {\n          const eKey = this.encoder.encodeKey(key);\n          return this.map !.get(key) !.map(value => eKey + '=' + this.encoder.encodeValue(value))\n              .join('&');\n        })\n        .join('&');\n  }\n\n  private clone(update: Update): HttpParams {\n    const clone = new HttpParams({ encoder: this.encoder } as HttpParamsOptions);\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat([update]);\n    return clone;\n  }\n\n  private init() {\n    if (this.map === null) {\n      this.map = new Map<string, string[]>();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach(key => this.map !.set(key, this.cloneFrom !.map !.get(key) !));\n      this.updates !.forEach(update => {\n        switch (update.op) {\n          case 'a':\n          case 's':\n            const base = (update.op === 'a' ? this.map !.get(update.param) : undefined) || [];\n            base.push(update.value !);\n            this.map !.set(update.param, base);\n            break;\n          case 'd':\n            if (update.value !== undefined) {\n              let base = this.map !.get(update.param) || [];\n              const idx = base.indexOf(update.value);\n              if (idx !== -1) {\n                base.splice(idx, 1);\n              }\n              if (base.length > 0) {\n                this.map !.set(update.param, base);\n              } else {\n                this.map !.delete(update.param);\n              }\n            } else {\n              this.map !.delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = null;\n    }\n  }\n}\n"]}