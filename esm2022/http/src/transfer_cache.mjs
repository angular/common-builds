/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { APP_BOOTSTRAP_LISTENER, ApplicationRef, inject, InjectionToken, makeStateKey, TransferState, ɵformatRuntimeError as formatRuntimeError, ɵperformanceMark as performanceMark, ɵtruncateMiddle as truncateMiddle, ɵwhenStable as whenStable } from '@angular/core';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { HttpHeaders } from './headers';
import { HTTP_ROOT_INTERCEPTOR_FNS } from './interceptor';
import { HttpResponse } from './response';
/**
 * Keys within cached response data structure.
 */
export const BODY = 'b';
export const HEADERS = 'h';
export const STATUS = 's';
export const STATUS_TEXT = 'st';
export const URL = 'u';
export const RESPONSE_TYPE = 'rt';
const CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');
/**
 * A list of allowed HTTP methods to cache.
 */
const ALLOWED_METHODS = ['GET', 'HEAD'];
export function transferCacheInterceptorFn(req, next) {
    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);
    const { transferCache: requestOptions, method: requestMethod } = req;
    // In the following situations we do not want to cache the request
    if (!isCacheActive ||
        // POST requests are allowed either globally or at request level
        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||
        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||
        requestOptions === false || //
        (globalOptions.filter?.(req)) === false) {
        return next(req);
    }
    const transferState = inject(TransferState);
    const storeKey = makeCacheKey(req);
    const response = transferState.get(storeKey, null);
    let headersToInclude = globalOptions.includeHeaders;
    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {
        // Request-specific config takes precedence over the global config.
        headersToInclude = requestOptions.includeHeaders;
    }
    if (response) {
        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [URL]: url } = response;
        // Request found in cache. Respond using it.
        let body = undecodedBody;
        switch (responseType) {
            case 'arraybuffer':
                body = new TextEncoder().encode(undecodedBody).buffer;
                break;
            case 'blob':
                body = new Blob([undecodedBody]);
                break;
        }
        // We want to warn users accessing a header provided from the cache
        // That HttpTransferCache alters the headers
        // The warning will be logged a single time by HttpHeaders instance
        let headers = new HttpHeaders(httpHeaders);
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            // Append extra logic in dev mode to produce a warning when a header
            // that was not transferred to the client is accessed in the code via `get`
            // and `has` calls.
            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);
        }
        return of(new HttpResponse({
            body,
            headers,
            status,
            statusText,
            url,
        }));
    }
    // Request not found in cache. Make the request and cache it.
    return next(req).pipe(tap((event) => {
        if (event instanceof HttpResponse) {
            transferState.set(storeKey, {
                [BODY]: event.body,
                [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
                [STATUS]: event.status,
                [STATUS_TEXT]: event.statusText,
                [URL]: event.url || '',
                [RESPONSE_TYPE]: req.responseType,
            });
        }
    }));
}
function getFilteredHeaders(headers, includeHeaders) {
    if (!includeHeaders) {
        return {};
    }
    const headersMap = {};
    for (const key of includeHeaders) {
        const values = headers.getAll(key);
        if (values !== null) {
            headersMap[key] = values;
        }
    }
    return headersMap;
}
function makeCacheKey(request) {
    // make the params encoded same as a url so it's easy to identify
    const { params, method, responseType, url } = request;
    const encodedParams = params.keys().sort().map((k) => `${k}=${params.getAll(k)}`).join('&');
    const key = method + '.' + responseType + '.' + url + '?' + encodedParams;
    const hash = generateHash(key);
    return makeStateKey(hash);
}
/**
 * A method that returns a hash representation of a string using a variant of DJB2 hash
 * algorithm.
 *
 * This is the same hashing logic that is used to generate component ids.
 */
function generateHash(value) {
    let hash = 0;
    for (const char of value) {
        hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
    }
    // Force positive number hash.
    // 2147483647 = equivalent of Integer.MAX_VALUE.
    hash += 2147483647 + 1;
    return hash.toString();
}
/**
 * Returns the DI providers needed to enable HTTP transfer cache.
 *
 * By default, when using server rendering, requests are performed twice: once on the server and
 * other one on the browser.
 *
 * When these providers are added, requests performed on the server are cached and reused during the
 * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing
 * load time.
 *
 */
export function withHttpTransferCache(cacheOptions) {
    return [
        {
            provide: CACHE_OPTIONS,
            useFactory: () => {
                performanceMark('mark_use_counter', { detail: { feature: 'NgHttpTransferCache' } });
                return { isCacheActive: true, ...cacheOptions };
            }
        },
        {
            provide: HTTP_ROOT_INTERCEPTOR_FNS,
            useValue: transferCacheInterceptorFn,
            multi: true,
            deps: [TransferState, CACHE_OPTIONS]
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            multi: true,
            useFactory: () => {
                const appRef = inject(ApplicationRef);
                const cacheState = inject(CACHE_OPTIONS);
                return () => {
                    whenStable(appRef).then(() => {
                        cacheState.isCacheActive = false;
                    });
                };
            }
        }
    ];
}
/**
 * This function will add a proxy to an HttpHeader to intercept calls to get/has
 * and log a warning if the header entry requested has been removed
 */
function appendMissingHeadersDetection(url, headers, headersToInclude) {
    const warningProduced = new Set();
    return new Proxy(headers, {
        get(target, prop) {
            const value = Reflect.get(target, prop);
            const methods = new Set(['get', 'has', 'getAll']);
            if (typeof value !== 'function' || !methods.has(prop)) {
                return value;
            }
            return (headerName) => {
                // We log when the key has been removed and a warning hasn't been produced for the header
                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`
                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
                    warningProduced.add(key);
                    const truncatedUrl = truncateMiddle(url);
                    // TODO: create Error guide for this warning
                    console.warn(formatRuntimeError(2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header ` +
                        `was not transferred from the server to the client by the HttpTransferCache. ` +
                        `To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, ` +
                        `use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either ` +
                        `on a request level by adding the \`transferCache\` parameter, or on an application ` +
                        `level by adding the \`httpCacheTransfer.includeHeaders\` argument to the ` +
                        `\`provideClientHydration()\` call. `));
                }
                // invoking the original method
                return value.apply(target, [headerName]);
            };
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfY2FjaGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21tb24vaHR0cC9zcmMvdHJhbnNmZXJfY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLHNCQUFzQixFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFlBQVksRUFBc0IsYUFBYSxFQUFFLG1CQUFtQixJQUFJLGtCQUFrQixFQUFFLGdCQUFnQixJQUFJLGVBQWUsRUFBRSxlQUFlLElBQUksY0FBYyxFQUFFLFdBQVcsSUFBSSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDNVIsT0FBTyxFQUFhLEVBQUUsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFHbkMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEVBQUMseUJBQXlCLEVBQWdCLE1BQU0sZUFBZSxDQUFDO0FBRXZFLE9BQU8sRUFBWSxZQUFZLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFxQm5EOztHQUVHO0FBRUgsTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUN4QixNQUFNLENBQUMsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDO0FBQzNCLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDMUIsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQUNoQyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ3ZCLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFzQmxDLE1BQU0sYUFBYSxHQUNmLElBQUksY0FBYyxDQUFlLFNBQVMsQ0FBQyxDQUFDLENBQUMsbUNBQW1DLENBQUMsQ0FBQyxDQUFDLEVB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Q0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNyRCxPQUFPLEtBQUssQ0FBQzthQUNkO1lBRUQsT0FBTyxDQUFDLFVBQWtCLEVBQUUsRUFBRTtnQkFDNUIseUZBQXlGO2dCQUN6RixNQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsVUFBVSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBRSwyQkFBMkI7Z0JBQ2pGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUN2RSxlQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN6QixNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRXpDLDRDQUE0QztvQkFDNUMsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsZ0VBRTNCLCtCQUNJLFVBQVUscURBQXFEO3dCQUMvRCw4RUFBOEU7d0JBQzlFLGlDQUFpQyxVQUFVLHVCQUN2QyxZQUFZLGNBQWM7d0JBQzlCLGdGQUFnRjt3QkFDaEYscUZBQXFGO3dCQUNyRiwyRUFBMkU7d0JBQzNFLHFDQUFxQyxDQUFDLENBQUMsQ0FBQztpQkFDakQ7Z0JBRUQsK0JBQStCO2dCQUMvQixPQUFRLEtBQWtCLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDekQsQ0FBQyxDQUFDO1FBQ0osQ0FBQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtBUFBfQk9PVFNUUkFQX0xJU1RFTkVSLCBBcHBsaWNhdGlvblJlZiwgaW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgbWFrZVN0YXRlS2V5LCBQcm92aWRlciwgU3RhdGVLZXksIFRyYW5zZmVyU3RhdGUsIMm1Zm9ybWF0UnVudGltZUVycm9yIGFzIGZvcm1hdFJ1bnRpbWVFcnJvciwgybVwZXJmb3JtYW5jZU1hcmsgYXMgcGVyZm9ybWFuY2VNYXJrLCDJtXRydW5jYXRlTWlkZGxlIGFzIHRydW5jYXRlTWlkZGxlLCDJtXdoZW5TdGFibGUgYXMgd2hlblN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7dGFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7UnVudGltZUVycm9yQ29kZX0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHtIdHRwSGVhZGVyc30gZnJvbSAnLi9oZWFkZXJzJztcbmltcG9ydCB7SFRUUF9ST09UX0lOVEVSQ0VQVE9SX0ZOUywgSHR0cEhhbmRsZXJGbn0gZnJvbSAnLi9pbnRlcmNlcHRvcic7XG5pbXBvcnQge0h0dHBSZXF1ZXN0fSBmcm9tICcuL3JlcXVlc3QnO1xuaW1wb3J0IHtIdHRwRXZlbnQsIEh0dHBSZXNwb25zZX0gZnJvbSAnLi9yZXNwb25zZSc7XG5cbi8qKlxuICogT3B0aW9ucyB0byBjb25maWd1cmUgaG93IFRyYW5zZmVyQ2FjaGUgc2hvdWxkIGJlIHVzZWQgdG8gY2FjaGUgcmVxdWVzdHMgbWFkZSB2aWEgSHR0cENsaWVudC5cbiAqXG4gKiBAcGFyYW0gaW5jbHVkZUhlYWRlcnMgU3BlY2lmaWVzIHdoaWNoIGhlYWRlcnMgc2hvdWxkIGJlIGluY2x1ZGVkIGludG8gY2FjaGVkIHJlc3BvbnNlcy4gTm9cbiAqICAgICBoZWFkZXJzIGFyZSBpbmNsdWRlZCBieSBkZWZhdWx0LlxuICogQHBhcmFtIGZpbHRlciBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSByZXF1ZXN0IGFzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZVxuICogICAgIHdoZXRoZXIgYSByZXF1ZXN0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSBpbmNsdWRlUG9zdFJlcXVlc3RzIEVuYWJsZXMgY2FjaGluZyBmb3IgUE9TVCByZXF1ZXN0cy4gQnkgZGVmYXVsdCwgb25seSBHRVQgYW5kIEhFQURcbiAqICAgICByZXF1ZXN0cyBhcmUgY2FjaGVkLiBUaGlzIG9wdGlvbiBjYW4gYmUgZW5hYmxlZCBpZiBQT1NUIHJlcXVlc3RzIGFyZSB1c2VkIHRvIHJldHJpZXZlIGRhdGFcbiAqICAgICAoZm9yIGV4YW1wbGUgdXNpbmcgR3JhcGhRTCkuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgdHlwZSBIdHRwVHJhbnNmZXJDYWNoZU9wdGlvbnMgPSB7XG4gIGluY2x1ZGVIZWFkZXJzPzogc3RyaW5nW10sXG4gIGZpbHRlcj86IChyZXE6IEh0dHBSZXF1ZXN0PHVua25vd24+KSA9PiBib29sZWFuLFxuICBpbmNsdWRlUG9zdFJlcXVlc3RzPzogYm9vbGVhblxufTtcblxuLyoqXG4gKiBLZXlzIHdpdGhpbiBjYWNoZWQgcmVzcG9uc2UgZGF0YSBzdHJ1Y3R1cmUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEJPRFkgPSAnYic7XG5leHBvcnQgY29uc3QgSEVBREVSUyA9ICdoJztcbmV4cG9ydCBjb25zdCBTVEFUVVMgPSAncyc7XG5leHBvcnQgY29uc3QgU1RBVFVTX1RFWFQgPSAnc3QnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICd1JztcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9UWVBFID0gJ3J0JztcblxuXG5pbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICAvKiogYm9keSAqL1xuICBbQk9EWV06IGFueTtcbiAgLyoqIGhlYWRlcnMgKi9cbiAgW0hFQURFUlNdOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT47XG4gIC8qKiBzdGF0dXMgKi9cbiAgW1NUQVRVU10/OiBudW1iZXI7XG4gIC8qKiBzdGF0dXNUZXh0ICovXG4gIFtTVEFUVVNfVEVYVF0/OiBzdHJpbmc7XG4gIC8qKiB1cmwgKi9cbiAgW1VSTF0/OiBzdHJpbmc7XG4gIC8qKiByZXNwb25zZVR5cGUgKi9cbiAgW1JFU1BPTlNFX1RZUEVdPzogSHR0cFJlcXVlc3Q8dW5rbm93bj5bJ3Jlc3BvbnNlVHlwZSddO1xufVxuXG5pbnRlcmZhY2UgQ2FjaGVPcHRpb25zIGV4dGVuZHMgSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zIHtcbiAgaXNDYWNoZUFjdGl2ZTogYm9vbGVhbjtcbn1cblxuY29uc3QgQ0FDSEVfT1BUSU9OUyA9XG4gICAgbmV3IEluamVjdGlvblRva2VuPENhY2hlT3B0aW9ucz4obmdEZXZNb2RlID8gJ0hUVFBfVFJBTlNGRVJfU1RBVEVfQ0FDSEVfT1BUSU9OUycgOiAnJyk7XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbG93ZWQgSFRUUCBtZXRob2RzIHRvIGNhY2hlLlxuICovXG5jb25zdCBBTExPV0VEX01FVEhPRFMgPSBbJ0dFVCcsICdIRUFEJ107XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2ZlckNhY2hlSW50ZXJjZXB0b3JGbihcbiAgICByZXE6IEh0dHBSZXF1ZXN0PHVua25vd24+LCBuZXh0OiBIdHRwSGFuZGxlckZuKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8dW5rbm93bj4+IHtcbiAgY29uc3Qge2lzQ2FjaGVBY3RpdmUsIC4uLmdsb2JhbE9wdGlvbnN9ID0gaW5qZWN0KENBQ0hFX09QVElPTlMpO1xuICBjb25zdCB7dHJhbnNmZXJDYWNoZTogcmVxdWVzdE9wdGlvbnMsIG1ldGhvZDogcmVxdWVzdE1ldGhvZH0gPSByZXE7XG5cbiAgLy8gSW4gdGhlIGZvbGxvd2luZyBzaXR1YXRpb25zIHdlIGRvIG5vdCB3YW50IHRvIGNhY2hlIHRoZSByZXF1ZXN0XG4gIGlmICghaXNDYWNoZUFjdGl2ZSB8fFxuICAgICAgLy8gUE9TVCByZXF1ZXN0cyBhcmUgYWxsb3dlZCBlaXRoZXIgZ2xvYmFsbHkgb3IgYXQgcmVxdWVzdCBsZXZlbFxuICAgICAgKHJlcXVlc3RNZXRob2QgPT09ICdQT1NUJyAmJiAhZ2xvYmFsT3B0aW9ucy5pbmNsdWRlUG9zdFJlcXVlc3RzICYmICFyZXF1ZXN0T3B0aW9ucykgfHxcbiAgICAgIChyZXF1ZXN0TWV0aG9kICE9PSAnUE9TVCcgJiYgIUFMTE9XRURfTUVUSE9EUy5pbmNsdWRlcyhyZXF1ZXN0TWV0aG9kKSkgfHxcbiAgICAgIHJlcXVlc3RPcHRpb25zID09PSBmYWxzZSB8fCAgLy9cbiAgICAgIChnbG9iYWxPcHRpb25zLmZpbHRlcj8uKHJlcSkpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBuZXh0KHJlcSk7XG4gIH1cblxuICBjb25zdCB0cmFuc2ZlclN0YXRlID0gaW5qZWN0KFRyYW5zZmVyU3RhdGUpO1xuICBjb25zdCBzdG9yZUtleSA9IG1ha2VDYWNoZUtleShyZXEpO1xuICBjb25zdCByZXNwb25zZSA9IHRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCBudWxsKTtcblxuICBsZXQgaGVhZGVyc1RvSW5jbHVkZSA9IGdsb2JhbE9wdGlvbnMuaW5jbHVkZUhlYWRlcnM7XG4gIGlmICh0eXBlb2YgcmVxdWVzdE9wdGlvbnMgPT09ICdvYmplY3QnICYmIHJlcXVlc3RPcHRpb25zLmluY2x1ZGVIZWFkZXJzKSB7XG4gICAgLy8gUmVxdWVzdC1zcGVjaWZpYyBjb25maWcgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBnbG9iYWwgY29uZmlnLlxuICAgIGhlYWRlcnNUb0luY2x1ZGUgPSByZXF1ZXN0T3B0aW9ucy5pbmNsdWRlSGVhZGVycztcbiAgfVxuXG4gIGlmIChyZXNwb25zZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFtCT0RZXTogdW5kZWNvZGVkQm9keSxcbiAgICAgIFtSRVNQT05TRV9UWVBFXTogcmVzcG9uc2VUeXBlLFxuICAgICAgW0hFQURFUlNdOiBodHRwSGVhZGVycyxcbiAgICAgIFtTVEFUVVNdOiBzdGF0dXMsXG4gICAgICBbU1RBVFVTX1RFWFRdOiBzdGF0dXNUZXh0LFxuICAgICAgW1VSTF06IHVybFxuICAgIH0gPSByZXNwb25zZTtcbiAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgIGxldCBib2R5OiBBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ3x1bmRlZmluZWQgPSB1bmRlY29kZWRCb2R5O1xuXG4gICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgYm9keSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1bmRlY29kZWRCb2R5KS5idWZmZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgIGJvZHkgPSBuZXcgQmxvYihbdW5kZWNvZGVkQm9keV0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIHdhcm4gdXNlcnMgYWNjZXNzaW5nIGEgaGVhZGVyIHByb3ZpZGVkIGZyb20gdGhlIGNhY2hlXG4gICAgLy8gVGhhdCBIdHRwVHJhbnNmZXJDYWNoZSBhbHRlcnMgdGhlIGhlYWRlcnNcbiAgICAvLyBUaGUgd2FybmluZyB3aWxsIGJlIGxvZ2dlZCBhIHNpbmdsZSB0aW1lIGJ5IEh0dHBIZWFkZXJzIGluc3RhbmNlXG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSHR0cEhlYWRlcnMoaHR0cEhlYWRlcnMpO1xuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgIC8vIEFwcGVuZCBleHRyYSBsb2dpYyBpbiBkZXYgbW9kZSB0byBwcm9kdWNlIGEgd2FybmluZyB3aGVuIGEgaGVhZGVyXG4gICAgICAvLyB0aGF0IHdhcyBub3QgdHJhbnNmZXJyZWQgdG8gdGhlIGNsaWVudCBpcyBhY2Nlc3NlZCBpbiB0aGUgY29kZSB2aWEgYGdldGBcbiAgICAgIC8vIGFuZCBgaGFzYCBjYWxscy5cbiAgICAgIGhlYWRlcnMgPSBhcHBlbmRNaXNzaW5nSGVhZGVyc0RldGVjdGlvbihyZXEudXJsLCBoZWFkZXJzLCBoZWFkZXJzVG9JbmNsdWRlID8/IFtdKTtcbiAgICB9XG5cblxuICAgIHJldHVybiBvZihcbiAgICAgICAgbmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgIHVybCxcbiAgICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG5cbiAgLy8gUmVxdWVzdCBub3QgZm91bmQgaW4gY2FjaGUuIE1ha2UgdGhlIHJlcXVlc3QgYW5kIGNhY2hlIGl0LlxuICByZXR1cm4gbmV4dChyZXEpLnBpcGUoXG4gICAgICB0YXAoKGV2ZW50OiBIdHRwRXZlbnQ8dW5rbm93bj4pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJhbnNmZXJTdGF0ZS5zZXQ8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KHN0b3JlS2V5LCB7XG4gICAgICAgICAgICBbQk9EWV06IGV2ZW50LmJvZHksXG4gICAgICAgICAgICBbSEVBREVSU106IGdldEZpbHRlcmVkSGVhZGVycyhldmVudC5oZWFkZXJzLCBoZWFkZXJzVG9JbmNsdWRlKSxcbiAgICAgICAgICAgIFtTVEFUVVNdOiBldmVudC5zdGF0dXMsXG4gICAgICAgICAgICBbU1RBVFVTX1RFWFRdOiBldmVudC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgW1VSTF06IGV2ZW50LnVybCB8fCAnJyxcbiAgICAgICAgICAgIFtSRVNQT05TRV9UWVBFXTogcmVxLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldEZpbHRlcmVkSGVhZGVycyhcbiAgICBoZWFkZXJzOiBIdHRwSGVhZGVycyxcbiAgICBpbmNsdWRlSGVhZGVyczogc3RyaW5nW118dW5kZWZpbmVkLFxuICAgICk6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiB7XG4gIGlmICghaW5jbHVkZUhlYWRlcnMpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBoZWFkZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgaW5jbHVkZUhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBoZWFkZXJzLmdldEFsbChrZXkpO1xuICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgIGhlYWRlcnNNYXBba2V5XSA9IHZhbHVlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGVhZGVyc01hcDtcbn1cblxuZnVuY3Rpb24gbWFrZUNhY2hlS2V5KHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4ge1xuICAvLyBtYWtlIHRoZSBwYXJhbXMgZW5jb2RlZCBzYW1lIGFzIGEgdXJsIHNvIGl0J3MgZWFzeSB0byBpZGVudGlmeVxuICBjb25zdCB7cGFyYW1zLCBtZXRob2QsIHJlc3BvbnNlVHlwZSwgdXJsfSA9IHJlcXVlc3Q7XG4gIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBwYXJhbXMua2V5cygpLnNvcnQoKS5tYXAoKGspID0+IGAke2t9PSR7cGFyYW1zLmdldEFsbChrKX1gKS5qb2luKCcmJyk7XG4gIGNvbnN0IGtleSA9IG1ldGhvZCArICcuJyArIHJlc3BvbnNlVHlwZSArICcuJyArIHVybCArICc/JyArIGVuY29kZWRQYXJhbXM7XG5cbiAgY29uc3QgaGFzaCA9IGdlbmVyYXRlSGFzaChrZXkpO1xuXG4gIHJldHVybiBtYWtlU3RhdGVLZXkoaGFzaCk7XG59XG5cbi8qKlxuICogQSBtZXRob2QgdGhhdCByZXR1cm5zIGEgaGFzaCByZXByZXNlbnRhdGlvbiBvZiBhIHN0cmluZyB1c2luZyBhIHZhcmlhbnQgb2YgREpCMiBoYXNoXG4gKiBhbGdvcml0aG0uXG4gKlxuICogVGhpcyBpcyB0aGUgc2FtZSBoYXNoaW5nIGxvZ2ljIHRoYXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBjb21wb25lbnQgaWRzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2godmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBoYXNoID0gMDtcblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBoYXNoID0gTWF0aC5pbXVsKDMxLCBoYXNoKSArIGNoYXIuY2hhckNvZGVBdCgwKSA8PCAwO1xuICB9XG5cbiAgLy8gRm9yY2UgcG9zaXRpdmUgbnVtYmVyIGhhc2guXG4gIC8vIDIxNDc0ODM2NDcgPSBlcXVpdmFsZW50IG9mIEludGVnZXIuTUFYX1ZBTFVFLlxuICBoYXNoICs9IDIxNDc0ODM2NDcgKyAxO1xuXG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgREkgcHJvdmlkZXJzIG5lZWRlZCB0byBlbmFibGUgSFRUUCB0cmFuc2ZlciBjYWNoZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIHVzaW5nIHNlcnZlciByZW5kZXJpbmcsIHJlcXVlc3RzIGFyZSBwZXJmb3JtZWQgdHdpY2U6IG9uY2Ugb24gdGhlIHNlcnZlciBhbmRcbiAqIG90aGVyIG9uZSBvbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBXaGVuIHRoZXNlIHByb3ZpZGVycyBhcmUgYWRkZWQsIHJlcXVlc3RzIHBlcmZvcm1lZCBvbiB0aGUgc2VydmVyIGFyZSBjYWNoZWQgYW5kIHJldXNlZCBkdXJpbmcgdGhlXG4gKiBib290c3RyYXBwaW5nIG9mIHRoZSBhcHBsaWNhdGlvbiBpbiB0aGUgYnJvd3NlciB0aHVzIGF2b2lkaW5nIGR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgcmVkdWNpbmdcbiAqIGxvYWQgdGltZS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoSHR0cFRyYW5zZmVyQ2FjaGUoY2FjaGVPcHRpb25zOiBIdHRwVHJhbnNmZXJDYWNoZU9wdGlvbnMpOiBQcm92aWRlcltdIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBDQUNIRV9PUFRJT05TLFxuICAgICAgdXNlRmFjdG9yeTogKCk6IENhY2hlT3B0aW9ucyA9PiB7XG4gICAgICAgIHBlcmZvcm1hbmNlTWFyaygnbWFya191c2VfY291bnRlcicsIHtkZXRhaWw6IHtmZWF0dXJlOiAnTmdIdHRwVHJhbnNmZXJDYWNoZSd9fSk7XG4gICAgICAgIHJldHVybiB7aXNDYWNoZUFjdGl2ZTogdHJ1ZSwgLi4uY2FjaGVPcHRpb25zfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IEhUVFBfUk9PVF9JTlRFUkNFUFRPUl9GTlMsXG4gICAgICB1c2VWYWx1ZTogdHJhbnNmZXJDYWNoZUludGVyY2VwdG9yRm4sXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgIGRlcHM6IFtUcmFuc2ZlclN0YXRlLCBDQUNIRV9PUFRJT05TXVxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogQVBQX0JPT1RTVFJBUF9MSVNURU5FUixcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgdXNlRmFjdG9yeTogKCkgPT4ge1xuICAgICAgICBjb25zdCBhcHBSZWYgPSBpbmplY3QoQXBwbGljYXRpb25SZWYpO1xuICAgICAgICBjb25zdCBjYWNoZVN0YXRlID0gaW5qZWN0KENBQ0hFX09QVElPTlMpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2hlblN0YWJsZShhcHBSZWYpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGVTdGF0ZS5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhIHByb3h5IHRvIGFuIEh0dHBIZWFkZXIgdG8gaW50ZXJjZXB0IGNhbGxzIHRvIGdldC9oYXNcbiAqIGFuZCBsb2cgYSB3YXJuaW5nIGlmIHRoZSBoZWFkZXIgZW50cnkgcmVxdWVzdGVkIGhhcyBiZWVuIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kTWlzc2luZ0hlYWRlcnNEZXRlY3Rpb24oXG4gICAgdXJsOiBzdHJpbmcsIGhlYWRlcnM6IEh0dHBIZWFkZXJzLCBoZWFkZXJzVG9JbmNsdWRlOiBzdHJpbmdbXSk6IEh0dHBIZWFkZXJzIHtcbiAgY29uc3Qgd2FybmluZ1Byb2R1Y2VkID0gbmV3IFNldCgpO1xuICByZXR1cm4gbmV3IFByb3h5PEh0dHBIZWFkZXJzPihoZWFkZXJzLCB7XG4gICAgZ2V0KHRhcmdldDogSHR0cEhlYWRlcnMsIHByb3A6IGtleW9mIEh0dHBIZWFkZXJzKTogdW5rbm93biB7XG4gICAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG4gICAgICBjb25zdCBtZXRob2RzOiBTZXQ8a2V5b2YgSHR0cEhlYWRlcnM+ID0gbmV3IFNldChbJ2dldCcsICdoYXMnLCAnZ2V0QWxsJ10pO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8ICFtZXRob2RzLmhhcyhwcm9wKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoaGVhZGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFdlIGxvZyB3aGVuIHRoZSBrZXkgaGFzIGJlZW4gcmVtb3ZlZCBhbmQgYSB3YXJuaW5nIGhhc24ndCBiZWVuIHByb2R1Y2VkIGZvciB0aGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IGtleSA9IChwcm9wICsgJzonICsgaGVhZGVyTmFtZSkudG9Mb3dlckNhc2UoKTsgIC8vIGUuZy4gYGdldDpjYWNoZS1jb250cm9sYFxuICAgICAgICBpZiAoIWhlYWRlcnNUb0luY2x1ZGUuaW5jbHVkZXMoaGVhZGVyTmFtZSkgJiYgIXdhcm5pbmdQcm9kdWNlZC5oYXMoa2V5KSkge1xuICAgICAgICAgIHdhcm5pbmdQcm9kdWNlZC5hZGQoa2V5KTtcbiAgICAgICAgICBjb25zdCB0cnVuY2F0ZWRVcmwgPSB0cnVuY2F0ZU1pZGRsZSh1cmwpO1xuXG4gICAgICAgICAgLy8gVE9ETzogY3JlYXRlIEVycm9yIGd1aWRlIGZvciB0aGlzIHdhcm5pbmdcbiAgICAgICAgICBjb25zb2xlLndhcm4oZm9ybWF0UnVudGltZUVycm9yKFxuICAgICAgICAgICAgICBSdW50aW1lRXJyb3JDb2RlLkhFQURFUlNfQUxURVJFRF9CWV9UUkFOU0ZFUl9DQUNIRSxcbiAgICAgICAgICAgICAgYEFuZ3VsYXIgZGV0ZWN0ZWQgdGhhdCB0aGUgXFxgJHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlck5hbWV9XFxgIGhlYWRlciBpcyBhY2Nlc3NlZCwgYnV0IHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyIGAgK1xuICAgICAgICAgICAgICAgICAgYHdhcyBub3QgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgYnkgdGhlIEh0dHBUcmFuc2ZlckNhY2hlLiBgICtcbiAgICAgICAgICAgICAgICAgIGBUbyBpbmNsdWRlIHRoZSB2YWx1ZSBvZiB0aGUgXFxgJHtoZWFkZXJOYW1lfVxcYCBoZWFkZXIgZm9yIHRoZSBcXGAke1xuICAgICAgICAgICAgICAgICAgICAgIHRydW5jYXRlZFVybH1cXGAgcmVxdWVzdCwgYCArXG4gICAgICAgICAgICAgICAgICBgdXNlIHRoZSBcXGBpbmNsdWRlSGVhZGVyc1xcYCBsaXN0LiBUaGUgXFxgaW5jbHVkZUhlYWRlcnNcXGAgY2FuIGJlIGRlZmluZWQgZWl0aGVyIGAgK1xuICAgICAgICAgICAgICAgICAgYG9uIGEgcmVxdWVzdCBsZXZlbCBieSBhZGRpbmcgdGhlIFxcYHRyYW5zZmVyQ2FjaGVcXGAgcGFyYW1ldGVyLCBvciBvbiBhbiBhcHBsaWNhdGlvbiBgICtcbiAgICAgICAgICAgICAgICAgIGBsZXZlbCBieSBhZGRpbmcgdGhlIFxcYGh0dHBDYWNoZVRyYW5zZmVyLmluY2x1ZGVIZWFkZXJzXFxgIGFyZ3VtZW50IHRvIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgIGBcXGBwcm92aWRlQ2xpZW50SHlkcmF0aW9uKClcXGAgY2FsbC4gYCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52b2tpbmcgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICByZXR1cm4gKHZhbHVlIGFzIEZ1bmN0aW9uKS5hcHBseSh0YXJnZXQsIFtoZWFkZXJOYW1lXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG4iXX0=