/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { APP_BOOTSTRAP_LISTENER, ApplicationRef, inject, InjectionToken, makeStateKey, TransferState, ɵformatRuntimeError as formatRuntimeError, ɵperformanceMarkFeature as performanceMarkFeature, ɵtruncateMiddle as truncateMiddle, ɵwhenStable as whenStable, PLATFORM_ID, } from '@angular/core';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { HttpHeaders } from './headers';
import { HTTP_ROOT_INTERCEPTOR_FNS } from './interceptor';
import { HttpResponse } from './response';
import { isPlatformServer } from '@angular/common';
/**
 * Keys within cached response data structure.
 */
export const BODY = 'b';
export const HEADERS = 'h';
export const STATUS = 's';
export const STATUS_TEXT = 'st';
export const URL = 'u';
export const RESPONSE_TYPE = 'rt';
const CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');
/**
 * A list of allowed HTTP methods to cache.
 */
const ALLOWED_METHODS = ['GET', 'HEAD'];
export function transferCacheInterceptorFn(req, next) {
    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);
    const { transferCache: requestOptions, method: requestMethod } = req;
    // In the following situations we do not want to cache the request
    if (!isCacheActive ||
        requestOptions === false ||
        // POST requests are allowed either globally or at request level
        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||
        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||
        // Do not cache request that require authorization when includeRequestsWithAuthHeaders is falsey
        (!globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req)) ||
        globalOptions.filter?.(req) === false) {
        return next(req);
    }
    const transferState = inject(TransferState);
    const storeKey = makeCacheKey(req);
    const response = transferState.get(storeKey, null);
    let headersToInclude = globalOptions.includeHeaders;
    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {
        // Request-specific config takes precedence over the global config.
        headersToInclude = requestOptions.includeHeaders;
    }
    if (response) {
        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [URL]: url, } = response;
        // Request found in cache. Respond using it.
        let body = undecodedBody;
        switch (responseType) {
            case 'arraybuffer':
                body = new TextEncoder().encode(undecodedBody).buffer;
                break;
            case 'blob':
                body = new Blob([undecodedBody]);
                break;
        }
        // We want to warn users accessing a header provided from the cache
        // That HttpTransferCache alters the headers
        // The warning will be logged a single time by HttpHeaders instance
        let headers = new HttpHeaders(httpHeaders);
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            // Append extra logic in dev mode to produce a warning when a header
            // that was not transferred to the client is accessed in the code via `get`
            // and `has` calls.
            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);
        }
        return of(new HttpResponse({
            body,
            headers,
            status,
            statusText,
            url,
        }));
    }
    const isServer = isPlatformServer(inject(PLATFORM_ID));
    // Request not found in cache. Make the request and cache it if on the server.
    return next(req).pipe(tap((event) => {
        if (event instanceof HttpResponse && isServer) {
            transferState.set(storeKey, {
                [BODY]: event.body,
                [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
                [STATUS]: event.status,
                [STATUS_TEXT]: event.statusText,
                [URL]: event.url || '',
                [RESPONSE_TYPE]: req.responseType,
            });
        }
    }));
}
/** @returns true when the requests contains autorization related headers. */
function hasAuthHeaders(req) {
    return req.headers.has('authorization') || req.headers.has('proxy-authorization');
}
function getFilteredHeaders(headers, includeHeaders) {
    if (!includeHeaders) {
        return {};
    }
    const headersMap = {};
    for (const key of includeHeaders) {
        const values = headers.getAll(key);
        if (values !== null) {
            headersMap[key] = values;
        }
    }
    return headersMap;
}
function sortAndConcatParams(params) {
    return [...params.keys()]
        .sort()
        .map((k) => `${k}=${params.getAll(k)}`)
        .join('&');
}
function makeCacheKey(request) {
    // make the params encoded same as a url so it's easy to identify
    const { params, method, responseType, url } = request;
    const encodedParams = sortAndConcatParams(params);
    let serializedBody = request.serializeBody();
    if (serializedBody instanceof URLSearchParams) {
        serializedBody = sortAndConcatParams(serializedBody);
    }
    else if (typeof serializedBody !== 'string') {
        serializedBody = '';
    }
    const key = [method, responseType, url, serializedBody, encodedParams].join('|');
    const hash = generateHash(key);
    return makeStateKey(hash);
}
/**
 * A method that returns a hash representation of a string using a variant of DJB2 hash
 * algorithm.
 *
 * This is the same hashing logic that is used to generate component ids.
 */
function generateHash(value) {
    let hash = 0;
    for (const char of value) {
        hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;
    }
    // Force positive number hash.
    // 2147483647 = equivalent of Integer.MAX_VALUE.
    hash += 2147483647 + 1;
    return hash.toString();
}
/**
 * Returns the DI providers needed to enable HTTP transfer cache.
 *
 * By default, when using server rendering, requests are performed twice: once on the server and
 * other one on the browser.
 *
 * When these providers are added, requests performed on the server are cached and reused during the
 * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing
 * load time.
 *
 */
export function withHttpTransferCache(cacheOptions) {
    return [
        {
            provide: CACHE_OPTIONS,
            useFactory: () => {
                performanceMarkFeature('NgHttpTransferCache');
                return { isCacheActive: true, ...cacheOptions };
            },
        },
        {
            provide: HTTP_ROOT_INTERCEPTOR_FNS,
            useValue: transferCacheInterceptorFn,
            multi: true,
            deps: [TransferState, CACHE_OPTIONS],
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            multi: true,
            useFactory: () => {
                const appRef = inject(ApplicationRef);
                const cacheState = inject(CACHE_OPTIONS);
                return () => {
                    whenStable(appRef).then(() => {
                        cacheState.isCacheActive = false;
                    });
                };
            },
        },
    ];
}
/**
 * This function will add a proxy to an HttpHeader to intercept calls to get/has
 * and log a warning if the header entry requested has been removed
 */
function appendMissingHeadersDetection(url, headers, headersToInclude) {
    const warningProduced = new Set();
    return new Proxy(headers, {
        get(target, prop) {
            const value = Reflect.get(target, prop);
            const methods = new Set(['get', 'has', 'getAll']);
            if (typeof value !== 'function' || !methods.has(prop)) {
                return value;
            }
            return (headerName) => {
                // We log when the key has been removed and a warning hasn't been produced for the header
                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`
                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
                    warningProduced.add(key);
                    const truncatedUrl = truncateMiddle(url);
                    // TODO: create Error guide for this warning
                    console.warn(formatRuntimeError(2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header ` +
                        `was not transferred from the server to the client by the HttpTransferCache. ` +
                        `To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, ` +
                        `use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either ` +
                        `on a request level by adding the \`transferCache\` parameter, or on an application ` +
                        `level by adding the \`httpCacheTransfer.includeHeaders\` argument to the ` +
                        `\`provideClientHydration()\` call. `));
                }
                // invoking the original method
                return value.apply(target, [headerName]);
            };
        },
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfY2FjaGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21tb24vaHR0cC9zcmMvdHJhbnNmZXJfY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUNMLHNCQUFzQixFQUN0QixjQUFjLEVBQ2QsTUFBTSxFQUNOLGNBQWMsRUFDZCxZQUFZLEVBR1osYUFBYSxFQUNiLG1CQUFtQixJQUFJLGtCQUFrQixFQUN6Qyx1QkFBdUIsSUFBSSxzQkFBc0IsRUFDakQsZUFBZSxJQUFJLGNBQWMsRUFDakMsV0FBVyxJQUFJLFVBQVUsRUFDekIsV0FBVyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYSxFQUFFLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBR25DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDdEMsT0FBTyxFQUFDLHlCQUF5QixFQUFnQixNQUFNLGVBQWUsQ0FBQztBQUV2RSxPQUFPLEVBQVksWUFBWSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRW5ELE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBd0JqRDs7R0FFRztBQUVILE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBRyxHQUFHLENBQUM7QUFDeEIsTUFBTSxDQUFDLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQztBQUMzQixNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQzFCLE1BQU0sQ0FBQyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDaEMsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN2QixNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDO0FBcUJsQyxNQUFNLGFBQWEsR0FB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Q0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsMkJBQTJCO2dCQUNoRixJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO29CQUN4RSxlQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN6QixNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRXpDLDRDQUE0QztvQkFDNUMsT0FBTyxDQUFDLElBQUksQ0FDVixrQkFBa0IsZ0VBRWhCLCtCQUErQixVQUFVLHFEQUFxRDt3QkFDNUYsOEVBQThFO3dCQUM5RSxpQ0FBaUMsVUFBVSx1QkFBdUIsWUFBWSxjQUFjO3dCQUM1RixnRkFBZ0Y7d0JBQ2hGLHFGQUFxRjt3QkFDckYsMkVBQTJFO3dCQUMzRSxxQ0FBcUMsQ0FDeEMsQ0FDRixDQUFDO2dCQUNKLENBQUM7Z0JBRUQsK0JBQStCO2dCQUMvQixPQUFRLEtBQWtCLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDekQsQ0FBQyxDQUFDO1FBQ0osQ0FBQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQVBQX0JPT1RTVFJBUF9MSVNURU5FUixcbiAgQXBwbGljYXRpb25SZWYsXG4gIGluamVjdCxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIG1ha2VTdGF0ZUtleSxcbiAgUHJvdmlkZXIsXG4gIFN0YXRlS2V5LFxuICBUcmFuc2ZlclN0YXRlLFxuICDJtWZvcm1hdFJ1bnRpbWVFcnJvciBhcyBmb3JtYXRSdW50aW1lRXJyb3IsXG4gIMm1cGVyZm9ybWFuY2VNYXJrRmVhdHVyZSBhcyBwZXJmb3JtYW5jZU1hcmtGZWF0dXJlLFxuICDJtXRydW5jYXRlTWlkZGxlIGFzIHRydW5jYXRlTWlkZGxlLFxuICDJtXdoZW5TdGFibGUgYXMgd2hlblN0YWJsZSxcbiAgUExBVEZPUk1fSUQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3RhcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1J1bnRpbWVFcnJvckNvZGV9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7SHR0cEhlYWRlcnN9IGZyb20gJy4vaGVhZGVycyc7XG5pbXBvcnQge0hUVFBfUk9PVF9JTlRFUkNFUFRPUl9GTlMsIEh0dHBIYW5kbGVyRm59IGZyb20gJy4vaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtIdHRwUmVxdWVzdH0gZnJvbSAnLi9yZXF1ZXN0JztcbmltcG9ydCB7SHR0cEV2ZW50LCBIdHRwUmVzcG9uc2V9IGZyb20gJy4vcmVzcG9uc2UnO1xuaW1wb3J0IHtIdHRwUGFyYW1zfSBmcm9tICcuL3BhcmFtcyc7XG5pbXBvcnQge2lzUGxhdGZvcm1TZXJ2ZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogT3B0aW9ucyB0byBjb25maWd1cmUgaG93IFRyYW5zZmVyQ2FjaGUgc2hvdWxkIGJlIHVzZWQgdG8gY2FjaGUgcmVxdWVzdHMgbWFkZSB2aWEgSHR0cENsaWVudC5cbiAqXG4gKiBAcGFyYW0gaW5jbHVkZUhlYWRlcnMgU3BlY2lmaWVzIHdoaWNoIGhlYWRlcnMgc2hvdWxkIGJlIGluY2x1ZGVkIGludG8gY2FjaGVkIHJlc3BvbnNlcy4gTm9cbiAqICAgICBoZWFkZXJzIGFyZSBpbmNsdWRlZCBieSBkZWZhdWx0LlxuICogQHBhcmFtIGZpbHRlciBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSByZXF1ZXN0IGFzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZVxuICogICAgIHdoZXRoZXIgYSByZXF1ZXN0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSBpbmNsdWRlUG9zdFJlcXVlc3RzIEVuYWJsZXMgY2FjaGluZyBmb3IgUE9TVCByZXF1ZXN0cy4gQnkgZGVmYXVsdCwgb25seSBHRVQgYW5kIEhFQURcbiAqICAgICByZXF1ZXN0cyBhcmUgY2FjaGVkLiBUaGlzIG9wdGlvbiBjYW4gYmUgZW5hYmxlZCBpZiBQT1NUIHJlcXVlc3RzIGFyZSB1c2VkIHRvIHJldHJpZXZlIGRhdGFcbiAqICAgICAoZm9yIGV4YW1wbGUgdXNpbmcgR3JhcGhRTCkuXG4gKiBAcGFyYW0gaW5jbHVkZVJlcXVlc3RzV2l0aEF1dGhIZWFkZXJzIEVuYWJsZXMgY2FjaGluZyBvZiByZXF1ZXN0cyBjb250YWluaW5nIGVpdGhlciBgQXV0aG9yaXphdGlvbmBcbiAqICAgICBvciBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVycy4gQnkgZGVmYXVsdCwgdGhlc2UgcmVxdWVzdHMgYXJlIGV4Y2x1ZGVkIGZyb20gY2FjaGluZy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCB0eXBlIEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyA9IHtcbiAgaW5jbHVkZUhlYWRlcnM/OiBzdHJpbmdbXTtcbiAgZmlsdGVyPzogKHJlcTogSHR0cFJlcXVlc3Q8dW5rbm93bj4pID0+IGJvb2xlYW47XG4gIGluY2x1ZGVQb3N0UmVxdWVzdHM/OiBib29sZWFuO1xuICBpbmNsdWRlUmVxdWVzdHNXaXRoQXV0aEhlYWRlcnM/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBLZXlzIHdpdGhpbiBjYWNoZWQgcmVzcG9uc2UgZGF0YSBzdHJ1Y3R1cmUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEJPRFkgPSAnYic7XG5leHBvcnQgY29uc3QgSEVBREVSUyA9ICdoJztcbmV4cG9ydCBjb25zdCBTVEFUVVMgPSAncyc7XG5leHBvcnQgY29uc3QgU1RBVFVTX1RFWFQgPSAnc3QnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICd1JztcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9UWVBFID0gJ3J0JztcblxuaW50ZXJmYWNlIFRyYW5zZmVySHR0cFJlc3BvbnNlIHtcbiAgLyoqIGJvZHkgKi9cbiAgW0JPRFldOiBhbnk7XG4gIC8qKiBoZWFkZXJzICovXG4gIFtIRUFERVJTXTogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+O1xuICAvKiogc3RhdHVzICovXG4gIFtTVEFUVVNdPzogbnVtYmVyO1xuICAvKiogc3RhdHVzVGV4dCAqL1xuICBbU1RBVFVTX1RFWFRdPzogc3RyaW5nO1xuICAvKiogdXJsICovXG4gIFtVUkxdPzogc3RyaW5nO1xuICAvKiogcmVzcG9uc2VUeXBlICovXG4gIFtSRVNQT05TRV9UWVBFXT86IEh0dHBSZXF1ZXN0PHVua25vd24+WydyZXNwb25zZVR5cGUnXTtcbn1cblxuaW50ZXJmYWNlIENhY2hlT3B0aW9ucyBleHRlbmRzIEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyB7XG4gIGlzQ2FjaGVBY3RpdmU6IGJvb2xlYW47XG59XG5cbmNvbnN0IENBQ0hFX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48Q2FjaGVPcHRpb25zPihcbiAgbmdEZXZNb2RlID8gJ0hUVFBfVFJBTlNGRVJfU1RBVEVfQ0FDSEVfT1BUSU9OUycgOiAnJyxcbik7XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbG93ZWQgSFRUUCBtZXRob2RzIHRvIGNhY2hlLlxuICovXG5jb25zdCBBTExPV0VEX01FVEhPRFMgPSBbJ0dFVCcsICdIRUFEJ107XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2ZlckNhY2hlSW50ZXJjZXB0b3JGbihcbiAgcmVxOiBIdHRwUmVxdWVzdDx1bmtub3duPixcbiAgbmV4dDogSHR0cEhhbmRsZXJGbixcbik6IE9ic2VydmFibGU8SHR0cEV2ZW50PHVua25vd24+PiB7XG4gIGNvbnN0IHtpc0NhY2hlQWN0aXZlLCAuLi5nbG9iYWxPcHRpb25zfSA9IGluamVjdChDQUNIRV9PUFRJT05TKTtcbiAgY29uc3Qge3RyYW5zZmVyQ2FjaGU6IHJlcXVlc3RPcHRpb25zLCBtZXRob2Q6IHJlcXVlc3RNZXRob2R9ID0gcmVxO1xuXG4gIC8vIEluIHRoZSBmb2xsb3dpbmcgc2l0dWF0aW9ucyB3ZSBkbyBub3Qgd2FudCB0byBjYWNoZSB0aGUgcmVxdWVzdFxuICBpZiAoXG4gICAgIWlzQ2FjaGVBY3RpdmUgfHxcbiAgICByZXF1ZXN0T3B0aW9ucyA9PT0gZmFsc2UgfHxcbiAgICAvLyBQT1NUIHJlcXVlc3RzIGFyZSBhbGxvd2VkIGVpdGhlciBnbG9iYWxseSBvciBhdCByZXF1ZXN0IGxldmVsXG4gICAgKHJlcXVlc3RNZXRob2QgPT09ICdQT1NUJyAmJiAhZ2xvYmFsT3B0aW9ucy5pbmNsdWRlUG9zdFJlcXVlc3RzICYmICFyZXF1ZXN0T3B0aW9ucykgfHxcbiAgICAocmVxdWVzdE1ldGhvZCAhPT0gJ1BPU1QnICYmICFBTExPV0VEX01FVEhPRFMuaW5jbHVkZXMocmVxdWVzdE1ldGhvZCkpIHx8XG4gICAgLy8gRG8gbm90IGNhY2hlIHJlcXVlc3QgdGhhdCByZXF1aXJlIGF1dGhvcml6YXRpb24gd2hlbiBpbmNsdWRlUmVxdWVzdHNXaXRoQXV0aEhlYWRlcnMgaXMgZmFsc2V5XG4gICAgKCFnbG9iYWxPcHRpb25zLmluY2x1ZGVSZXF1ZXN0c1dpdGhBdXRoSGVhZGVycyAmJiBoYXNBdXRoSGVhZGVycyhyZXEpKSB8fFxuICAgIGdsb2JhbE9wdGlvbnMuZmlsdGVyPy4ocmVxKSA9PT0gZmFsc2VcbiAgKSB7XG4gICAgcmV0dXJuIG5leHQocmVxKTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZmVyU3RhdGUgPSBpbmplY3QoVHJhbnNmZXJTdGF0ZSk7XG4gIGNvbnN0IHN0b3JlS2V5ID0gbWFrZUNhY2hlS2V5KHJlcSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gdHJhbnNmZXJTdGF0ZS5nZXQoc3RvcmVLZXksIG51bGwpO1xuXG4gIGxldCBoZWFkZXJzVG9JbmNsdWRlID0gZ2xvYmFsT3B0aW9ucy5pbmNsdWRlSGVhZGVycztcbiAgaWYgKHR5cGVvZiByZXF1ZXN0T3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgcmVxdWVzdE9wdGlvbnMuaW5jbHVkZUhlYWRlcnMpIHtcbiAgICAvLyBSZXF1ZXN0LXNwZWNpZmljIGNvbmZpZyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGdsb2JhbCBjb25maWcuXG4gICAgaGVhZGVyc1RvSW5jbHVkZSA9IHJlcXVlc3RPcHRpb25zLmluY2x1ZGVIZWFkZXJzO1xuICB9XG5cbiAgaWYgKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgW0JPRFldOiB1bmRlY29kZWRCb2R5LFxuICAgICAgW1JFU1BPTlNFX1RZUEVdOiByZXNwb25zZVR5cGUsXG4gICAgICBbSEVBREVSU106IGh0dHBIZWFkZXJzLFxuICAgICAgW1NUQVRVU106IHN0YXR1cyxcbiAgICAgIFtTVEFUVVNfVEVYVF06IHN0YXR1c1RleHQsXG4gICAgICBbVVJMXTogdXJsLFxuICAgIH0gPSByZXNwb25zZTtcbiAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgIGxldCBib2R5OiBBcnJheUJ1ZmZlciB8IEJsb2IgfCBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlY29kZWRCb2R5O1xuXG4gICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgYm9keSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1bmRlY29kZWRCb2R5KS5idWZmZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgIGJvZHkgPSBuZXcgQmxvYihbdW5kZWNvZGVkQm9keV0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIHdhcm4gdXNlcnMgYWNjZXNzaW5nIGEgaGVhZGVyIHByb3ZpZGVkIGZyb20gdGhlIGNhY2hlXG4gICAgLy8gVGhhdCBIdHRwVHJhbnNmZXJDYWNoZSBhbHRlcnMgdGhlIGhlYWRlcnNcbiAgICAvLyBUaGUgd2FybmluZyB3aWxsIGJlIGxvZ2dlZCBhIHNpbmdsZSB0aW1lIGJ5IEh0dHBIZWFkZXJzIGluc3RhbmNlXG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSHR0cEhlYWRlcnMoaHR0cEhlYWRlcnMpO1xuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgIC8vIEFwcGVuZCBleHRyYSBsb2dpYyBpbiBkZXYgbW9kZSB0byBwcm9kdWNlIGEgd2FybmluZyB3aGVuIGEgaGVhZGVyXG4gICAgICAvLyB0aGF0IHdhcyBub3QgdHJhbnNmZXJyZWQgdG8gdGhlIGNsaWVudCBpcyBhY2Nlc3NlZCBpbiB0aGUgY29kZSB2aWEgYGdldGBcbiAgICAgIC8vIGFuZCBgaGFzYCBjYWxscy5cbiAgICAgIGhlYWRlcnMgPSBhcHBlbmRNaXNzaW5nSGVhZGVyc0RldGVjdGlvbihyZXEudXJsLCBoZWFkZXJzLCBoZWFkZXJzVG9JbmNsdWRlID8/IFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2YoXG4gICAgICBuZXcgSHR0cFJlc3BvbnNlKHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaXNTZXJ2ZXIgPSBpc1BsYXRmb3JtU2VydmVyKGluamVjdChQTEFURk9STV9JRCkpO1xuXG4gIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdCBpZiBvbiB0aGUgc2VydmVyLlxuICByZXR1cm4gbmV4dChyZXEpLnBpcGUoXG4gICAgdGFwKChldmVudDogSHR0cEV2ZW50PHVua25vd24+KSA9PiB7XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UgJiYgaXNTZXJ2ZXIpIHtcbiAgICAgICAgdHJhbnNmZXJTdGF0ZS5zZXQ8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KHN0b3JlS2V5LCB7XG4gICAgICAgICAgW0JPRFldOiBldmVudC5ib2R5LFxuICAgICAgICAgIFtIRUFERVJTXTogZ2V0RmlsdGVyZWRIZWFkZXJzKGV2ZW50LmhlYWRlcnMsIGhlYWRlcnNUb0luY2x1ZGUpLFxuICAgICAgICAgIFtTVEFUVVNdOiBldmVudC5zdGF0dXMsXG4gICAgICAgICAgW1NUQVRVU19URVhUXTogZXZlbnQuc3RhdHVzVGV4dCxcbiAgICAgICAgICBbVVJMXTogZXZlbnQudXJsIHx8ICcnLFxuICAgICAgICAgIFtSRVNQT05TRV9UWVBFXTogcmVxLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG59XG5cbi8qKiBAcmV0dXJucyB0cnVlIHdoZW4gdGhlIHJlcXVlc3RzIGNvbnRhaW5zIGF1dG9yaXphdGlvbiByZWxhdGVkIGhlYWRlcnMuICovXG5mdW5jdGlvbiBoYXNBdXRoSGVhZGVycyhyZXE6IEh0dHBSZXF1ZXN0PHVua25vd24+KTogYm9vbGVhbiB7XG4gIHJldHVybiByZXEuaGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSB8fCByZXEuaGVhZGVycy5oYXMoJ3Byb3h5LWF1dGhvcml6YXRpb24nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsdGVyZWRIZWFkZXJzKFxuICBoZWFkZXJzOiBIdHRwSGVhZGVycyxcbiAgaW5jbHVkZUhlYWRlcnM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuKTogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+IHtcbiAgaWYgKCFpbmNsdWRlSGVhZGVycykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBpbmNsdWRlSGVhZGVycykge1xuICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnMuZ2V0QWxsKGtleSk7XG4gICAgaWYgKHZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgaGVhZGVyc01hcFtrZXldID0gdmFsdWVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzTWFwO1xufVxuXG5mdW5jdGlvbiBzb3J0QW5kQ29uY2F0UGFyYW1zKHBhcmFtczogSHR0cFBhcmFtcyB8IFVSTFNlYXJjaFBhcmFtcyk6IHN0cmluZyB7XG4gIHJldHVybiBbLi4ucGFyYW1zLmtleXMoKV1cbiAgICAuc29ydCgpXG4gICAgLm1hcCgoaykgPT4gYCR7a309JHtwYXJhbXMuZ2V0QWxsKGspfWApXG4gICAgLmpvaW4oJyYnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNhY2hlS2V5KHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4ge1xuICAvLyBtYWtlIHRoZSBwYXJhbXMgZW5jb2RlZCBzYW1lIGFzIGEgdXJsIHNvIGl0J3MgZWFzeSB0byBpZGVudGlmeVxuICBjb25zdCB7cGFyYW1zLCBtZXRob2QsIHJlc3BvbnNlVHlwZSwgdXJsfSA9IHJlcXVlc3Q7XG4gIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBzb3J0QW5kQ29uY2F0UGFyYW1zKHBhcmFtcyk7XG5cbiAgbGV0IHNlcmlhbGl6ZWRCb2R5ID0gcmVxdWVzdC5zZXJpYWxpemVCb2R5KCk7XG4gIGlmIChzZXJpYWxpemVkQm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHNlcmlhbGl6ZWRCb2R5ID0gc29ydEFuZENvbmNhdFBhcmFtcyhzZXJpYWxpemVkQm9keSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlcmlhbGl6ZWRCb2R5ICE9PSAnc3RyaW5nJykge1xuICAgIHNlcmlhbGl6ZWRCb2R5ID0gJyc7XG4gIH1cblxuICBjb25zdCBrZXkgPSBbbWV0aG9kLCByZXNwb25zZVR5cGUsIHVybCwgc2VyaWFsaXplZEJvZHksIGVuY29kZWRQYXJhbXNdLmpvaW4oJ3wnKTtcbiAgY29uc3QgaGFzaCA9IGdlbmVyYXRlSGFzaChrZXkpO1xuXG4gIHJldHVybiBtYWtlU3RhdGVLZXkoaGFzaCk7XG59XG5cbi8qKlxuICogQSBtZXRob2QgdGhhdCByZXR1cm5zIGEgaGFzaCByZXByZXNlbnRhdGlvbiBvZiBhIHN0cmluZyB1c2luZyBhIHZhcmlhbnQgb2YgREpCMiBoYXNoXG4gKiBhbGdvcml0aG0uXG4gKlxuICogVGhpcyBpcyB0aGUgc2FtZSBoYXNoaW5nIGxvZ2ljIHRoYXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBjb21wb25lbnQgaWRzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2godmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBoYXNoID0gMDtcblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBoYXNoID0gKE1hdGguaW11bCgzMSwgaGFzaCkgKyBjaGFyLmNoYXJDb2RlQXQoMCkpIDw8IDA7XG4gIH1cblxuICAvLyBGb3JjZSBwb3NpdGl2ZSBudW1iZXIgaGFzaC5cbiAgLy8gMjE0NzQ4MzY0NyA9IGVxdWl2YWxlbnQgb2YgSW50ZWdlci5NQVhfVkFMVUUuXG4gIGhhc2ggKz0gMjE0NzQ4MzY0NyArIDE7XG5cbiAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBESSBwcm92aWRlcnMgbmVlZGVkIHRvIGVuYWJsZSBIVFRQIHRyYW5zZmVyIGNhY2hlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gdXNpbmcgc2VydmVyIHJlbmRlcmluZywgcmVxdWVzdHMgYXJlIHBlcmZvcm1lZCB0d2ljZTogb25jZSBvbiB0aGUgc2VydmVyIGFuZFxuICogb3RoZXIgb25lIG9uIHRoZSBicm93c2VyLlxuICpcbiAqIFdoZW4gdGhlc2UgcHJvdmlkZXJzIGFyZSBhZGRlZCwgcmVxdWVzdHMgcGVyZm9ybWVkIG9uIHRoZSBzZXJ2ZXIgYXJlIGNhY2hlZCBhbmQgcmV1c2VkIGR1cmluZyB0aGVcbiAqIGJvb3RzdHJhcHBpbmcgb2YgdGhlIGFwcGxpY2F0aW9uIGluIHRoZSBicm93c2VyIHRodXMgYXZvaWRpbmcgZHVwbGljYXRlIHJlcXVlc3RzIGFuZCByZWR1Y2luZ1xuICogbG9hZCB0aW1lLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhIdHRwVHJhbnNmZXJDYWNoZShjYWNoZU9wdGlvbnM6IEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyk6IFByb3ZpZGVyW10ge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IENBQ0hFX09QVElPTlMsXG4gICAgICB1c2VGYWN0b3J5OiAoKTogQ2FjaGVPcHRpb25zID0+IHtcbiAgICAgICAgcGVyZm9ybWFuY2VNYXJrRmVhdHVyZSgnTmdIdHRwVHJhbnNmZXJDYWNoZScpO1xuICAgICAgICByZXR1cm4ge2lzQ2FjaGVBY3RpdmU6IHRydWUsIC4uLmNhY2hlT3B0aW9uc307XG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogSFRUUF9ST09UX0lOVEVSQ0VQVE9SX0ZOUyxcbiAgICAgIHVzZVZhbHVlOiB0cmFuc2ZlckNhY2hlSW50ZXJjZXB0b3JGbixcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgZGVwczogW1RyYW5zZmVyU3RhdGUsIENBQ0hFX09QVElPTlNdLFxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogQVBQX0JPT1RTVFJBUF9MSVNURU5FUixcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgdXNlRmFjdG9yeTogKCkgPT4ge1xuICAgICAgICBjb25zdCBhcHBSZWYgPSBpbmplY3QoQXBwbGljYXRpb25SZWYpO1xuICAgICAgICBjb25zdCBjYWNoZVN0YXRlID0gaW5qZWN0KENBQ0hFX09QVElPTlMpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2hlblN0YWJsZShhcHBSZWYpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGVTdGF0ZS5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhIHByb3h5IHRvIGFuIEh0dHBIZWFkZXIgdG8gaW50ZXJjZXB0IGNhbGxzIHRvIGdldC9oYXNcbiAqIGFuZCBsb2cgYSB3YXJuaW5nIGlmIHRoZSBoZWFkZXIgZW50cnkgcmVxdWVzdGVkIGhhcyBiZWVuIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kTWlzc2luZ0hlYWRlcnNEZXRlY3Rpb24oXG4gIHVybDogc3RyaW5nLFxuICBoZWFkZXJzOiBIdHRwSGVhZGVycyxcbiAgaGVhZGVyc1RvSW5jbHVkZTogc3RyaW5nW10sXG4pOiBIdHRwSGVhZGVycyB7XG4gIGNvbnN0IHdhcm5pbmdQcm9kdWNlZCA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIG5ldyBQcm94eTxIdHRwSGVhZGVycz4oaGVhZGVycywge1xuICAgIGdldCh0YXJnZXQ6IEh0dHBIZWFkZXJzLCBwcm9wOiBrZXlvZiBIdHRwSGVhZGVycyk6IHVua25vd24ge1xuICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgY29uc3QgbWV0aG9kczogU2V0PGtleW9mIEh0dHBIZWFkZXJzPiA9IG5ldyBTZXQoWydnZXQnLCAnaGFzJywgJ2dldEFsbCddKTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhbWV0aG9kcy5oYXMocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKGhlYWRlck5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBXZSBsb2cgd2hlbiB0aGUga2V5IGhhcyBiZWVuIHJlbW92ZWQgYW5kIGEgd2FybmluZyBoYXNuJ3QgYmVlbiBwcm9kdWNlZCBmb3IgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBrZXkgPSAocHJvcCArICc6JyArIGhlYWRlck5hbWUpLnRvTG93ZXJDYXNlKCk7IC8vIGUuZy4gYGdldDpjYWNoZS1jb250cm9sYFxuICAgICAgICBpZiAoIWhlYWRlcnNUb0luY2x1ZGUuaW5jbHVkZXMoaGVhZGVyTmFtZSkgJiYgIXdhcm5pbmdQcm9kdWNlZC5oYXMoa2V5KSkge1xuICAgICAgICAgIHdhcm5pbmdQcm9kdWNlZC5hZGQoa2V5KTtcbiAgICAgICAgICBjb25zdCB0cnVuY2F0ZWRVcmwgPSB0cnVuY2F0ZU1pZGRsZSh1cmwpO1xuXG4gICAgICAgICAgLy8gVE9ETzogY3JlYXRlIEVycm9yIGd1aWRlIGZvciB0aGlzIHdhcm5pbmdcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBmb3JtYXRSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICAgIFJ1bnRpbWVFcnJvckNvZGUuSEVBREVSU19BTFRFUkVEX0JZX1RSQU5TRkVSX0NBQ0hFLFxuICAgICAgICAgICAgICBgQW5ndWxhciBkZXRlY3RlZCB0aGF0IHRoZSBcXGAke2hlYWRlck5hbWV9XFxgIGhlYWRlciBpcyBhY2Nlc3NlZCwgYnV0IHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyIGAgK1xuICAgICAgICAgICAgICAgIGB3YXMgbm90IHRyYW5zZmVycmVkIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IGJ5IHRoZSBIdHRwVHJhbnNmZXJDYWNoZS4gYCArXG4gICAgICAgICAgICAgICAgYFRvIGluY2x1ZGUgdGhlIHZhbHVlIG9mIHRoZSBcXGAke2hlYWRlck5hbWV9XFxgIGhlYWRlciBmb3IgdGhlIFxcYCR7dHJ1bmNhdGVkVXJsfVxcYCByZXF1ZXN0LCBgICtcbiAgICAgICAgICAgICAgICBgdXNlIHRoZSBcXGBpbmNsdWRlSGVhZGVyc1xcYCBsaXN0LiBUaGUgXFxgaW5jbHVkZUhlYWRlcnNcXGAgY2FuIGJlIGRlZmluZWQgZWl0aGVyIGAgK1xuICAgICAgICAgICAgICAgIGBvbiBhIHJlcXVlc3QgbGV2ZWwgYnkgYWRkaW5nIHRoZSBcXGB0cmFuc2ZlckNhY2hlXFxgIHBhcmFtZXRlciwgb3Igb24gYW4gYXBwbGljYXRpb24gYCArXG4gICAgICAgICAgICAgICAgYGxldmVsIGJ5IGFkZGluZyB0aGUgXFxgaHR0cENhY2hlVHJhbnNmZXIuaW5jbHVkZUhlYWRlcnNcXGAgYXJndW1lbnQgdG8gdGhlIGAgK1xuICAgICAgICAgICAgICAgIGBcXGBwcm92aWRlQ2xpZW50SHlkcmF0aW9uKClcXGAgY2FsbC4gYCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGludm9raW5nIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgICAgcmV0dXJuICh2YWx1ZSBhcyBGdW5jdGlvbikuYXBwbHkodGFyZ2V0LCBbaGVhZGVyTmFtZV0pO1xuICAgICAgfTtcbiAgICB9LFxuICB9KTtcbn1cbiJdfQ==