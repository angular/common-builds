/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { APP_BOOTSTRAP_LISTENER, ApplicationRef, inject, InjectionToken, makeStateKey, TransferState, ɵformatRuntimeError as formatRuntimeError, ɵperformanceMarkFeature as performanceMarkFeature, ɵtruncateMiddle as truncateMiddle, ɵwhenStable as whenStable, } from '@angular/core';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { HttpHeaders } from './headers';
import { HTTP_ROOT_INTERCEPTOR_FNS } from './interceptor';
import { HttpResponse } from './response';
/**
 * Keys within cached response data structure.
 */
export const BODY = 'b';
export const HEADERS = 'h';
export const STATUS = 's';
export const STATUS_TEXT = 'st';
export const URL = 'u';
export const RESPONSE_TYPE = 'rt';
const CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');
/**
 * A list of allowed HTTP methods to cache.
 */
const ALLOWED_METHODS = ['GET', 'HEAD'];
export function transferCacheInterceptorFn(req, next) {
    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);
    const { transferCache: requestOptions, method: requestMethod } = req;
    // In the following situations we do not want to cache the request
    if (!isCacheActive ||
        // POST requests are allowed either globally or at request level
        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||
        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||
        // Do not cache request that require authorization
        req.headers.has('authorization') ||
        req.headers.has('proxy-authorization') ||
        requestOptions === false ||
        globalOptions.filter?.(req) === false) {
        return next(req);
    }
    const transferState = inject(TransferState);
    const storeKey = makeCacheKey(req);
    const response = transferState.get(storeKey, null);
    let headersToInclude = globalOptions.includeHeaders;
    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {
        // Request-specific config takes precedence over the global config.
        headersToInclude = requestOptions.includeHeaders;
    }
    if (response) {
        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [URL]: url, } = response;
        // Request found in cache. Respond using it.
        let body = undecodedBody;
        switch (responseType) {
            case 'arraybuffer':
                body = new TextEncoder().encode(undecodedBody).buffer;
                break;
            case 'blob':
                body = new Blob([undecodedBody]);
                break;
        }
        // We want to warn users accessing a header provided from the cache
        // That HttpTransferCache alters the headers
        // The warning will be logged a single time by HttpHeaders instance
        let headers = new HttpHeaders(httpHeaders);
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            // Append extra logic in dev mode to produce a warning when a header
            // that was not transferred to the client is accessed in the code via `get`
            // and `has` calls.
            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);
        }
        return of(new HttpResponse({
            body,
            headers,
            status,
            statusText,
            url,
        }));
    }
    // Request not found in cache. Make the request and cache it.
    return next(req).pipe(tap((event) => {
        if (event instanceof HttpResponse) {
            transferState.set(storeKey, {
                [BODY]: event.body,
                [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
                [STATUS]: event.status,
                [STATUS_TEXT]: event.statusText,
                [URL]: event.url || '',
                [RESPONSE_TYPE]: req.responseType,
            });
        }
    }));
}
function getFilteredHeaders(headers, includeHeaders) {
    if (!includeHeaders) {
        return {};
    }
    const headersMap = {};
    for (const key of includeHeaders) {
        const values = headers.getAll(key);
        if (values !== null) {
            headersMap[key] = values;
        }
    }
    return headersMap;
}
function sortAndConcatParams(params) {
    return [...params.keys()]
        .sort()
        .map((k) => `${k}=${params.getAll(k)}`)
        .join('&');
}
function makeCacheKey(request) {
    // make the params encoded same as a url so it's easy to identify
    const { params, method, responseType, url } = request;
    const encodedParams = sortAndConcatParams(params);
    let serializedBody = request.serializeBody();
    if (serializedBody instanceof URLSearchParams) {
        serializedBody = sortAndConcatParams(serializedBody);
    }
    else if (typeof serializedBody !== 'string') {
        serializedBody = '';
    }
    const key = [method, responseType, url, serializedBody, encodedParams].join('|');
    const hash = generateHash(key);
    return makeStateKey(hash);
}
/**
 * A method that returns a hash representation of a string using a variant of DJB2 hash
 * algorithm.
 *
 * This is the same hashing logic that is used to generate component ids.
 */
function generateHash(value) {
    let hash = 0;
    for (const char of value) {
        hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;
    }
    // Force positive number hash.
    // 2147483647 = equivalent of Integer.MAX_VALUE.
    hash += 2147483647 + 1;
    return hash.toString();
}
/**
 * Returns the DI providers needed to enable HTTP transfer cache.
 *
 * By default, when using server rendering, requests are performed twice: once on the server and
 * other one on the browser.
 *
 * When these providers are added, requests performed on the server are cached and reused during the
 * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing
 * load time.
 *
 */
export function withHttpTransferCache(cacheOptions) {
    return [
        {
            provide: CACHE_OPTIONS,
            useFactory: () => {
                performanceMarkFeature('NgHttpTransferCache');
                return { isCacheActive: true, ...cacheOptions };
            },
        },
        {
            provide: HTTP_ROOT_INTERCEPTOR_FNS,
            useValue: transferCacheInterceptorFn,
            multi: true,
            deps: [TransferState, CACHE_OPTIONS],
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            multi: true,
            useFactory: () => {
                const appRef = inject(ApplicationRef);
                const cacheState = inject(CACHE_OPTIONS);
                return () => {
                    whenStable(appRef).then(() => {
                        cacheState.isCacheActive = false;
                    });
                };
            },
        },
    ];
}
/**
 * This function will add a proxy to an HttpHeader to intercept calls to get/has
 * and log a warning if the header entry requested has been removed
 */
function appendMissingHeadersDetection(url, headers, headersToInclude) {
    const warningProduced = new Set();
    return new Proxy(headers, {
        get(target, prop) {
            const value = Reflect.get(target, prop);
            const methods = new Set(['get', 'has', 'getAll']);
            if (typeof value !== 'function' || !methods.has(prop)) {
                return value;
            }
            return (headerName) => {
                // We log when the key has been removed and a warning hasn't been produced for the header
                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`
                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
                    warningProduced.add(key);
                    const truncatedUrl = truncateMiddle(url);
                    // TODO: create Error guide for this warning
                    console.warn(formatRuntimeError(2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header ` +
                        `was not transferred from the server to the client by the HttpTransferCache. ` +
                        `To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, ` +
                        `use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either ` +
                        `on a request level by adding the \`transferCache\` parameter, or on an application ` +
                        `level by adding the \`httpCacheTransfer.includeHeaders\` argument to the ` +
                        `\`provideClientHydration()\` call. `));
                }
                // invoking the original method
                return value.apply(target, [headerName]);
            };
        },
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfY2FjaGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21tb24vaHR0cC9zcmMvdHJhbnNmZXJfY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUNMLHNCQUFzQixFQUN0QixjQUFjLEVBQ2QsTUFBTSxFQUNOLGNBQWMsRUFDZCxZQUFZLEVBR1osYUFBYSxFQUNiLG1CQUFtQixJQUFJLGtCQUFrQixFQUN6Qyx1QkFBdUIsSUFBSSxzQkFBc0IsRUFDakQsZUFBZSxJQUFJLGNBQWMsRUFDakMsV0FBVyxJQUFJLFVBQVUsR0FDMUIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFhLEVBQUUsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFHbkMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEVBQUMseUJBQXlCLEVBQWdCLE1BQU0sZUFBZSxDQUFDO0FBRXZFLE9BQU8sRUFBWSxZQUFZLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFzQm5EOztHQUVHO0FBRUgsTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUN4QixNQUFNLENBQUMsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDO0FBQzNCLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDMUIsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQUNoQyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ3ZCLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFxQmxDLE1BQU0sYUFBYSxHQUFHLElBQUksY0FBYyxDQUN0QyxTQUFTLENBQUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDLENBQUMs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LENBQUMsSUFBSSxDQUNWLGtCQUFrQixnRUFFaEIsK0JBQStCLFVBQVUscURBQXFEO3dCQUM1Riw4RUFBOEU7d0JBQzlFLGlDQUFpQyxVQUFVLHVCQUF1QixZQUFZLGNBQWM7d0JBQzVGLGdGQUFnRjt3QkFDaEYscUZBQXFGO3dCQUNyRiwyRUFBMkU7d0JBQzNFLHFDQUFxQyxDQUN4QyxDQUNGLENBQUM7Z0JBQ0osQ0FBQztnQkFFRCwrQkFBK0I7Z0JBQy9CLE9BQVEsS0FBa0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUN6RCxDQUFDLENBQUM7UUFDSixDQUFDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSLFxuICBBcHBsaWNhdGlvblJlZixcbiAgaW5qZWN0LFxuICBJbmplY3Rpb25Ub2tlbixcbiAgbWFrZVN0YXRlS2V5LFxuICBQcm92aWRlcixcbiAgU3RhdGVLZXksXG4gIFRyYW5zZmVyU3RhdGUsXG4gIMm1Zm9ybWF0UnVudGltZUVycm9yIGFzIGZvcm1hdFJ1bnRpbWVFcnJvcixcbiAgybVwZXJmb3JtYW5jZU1hcmtGZWF0dXJlIGFzIHBlcmZvcm1hbmNlTWFya0ZlYXR1cmUsXG4gIMm1dHJ1bmNhdGVNaWRkbGUgYXMgdHJ1bmNhdGVNaWRkbGUsXG4gIMm1d2hlblN0YWJsZSBhcyB3aGVuU3RhYmxlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHt0YXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtSdW50aW1lRXJyb3JDb2RlfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge0h0dHBIZWFkZXJzfSBmcm9tICcuL2hlYWRlcnMnO1xuaW1wb3J0IHtIVFRQX1JPT1RfSU5URVJDRVBUT1JfRk5TLCBIdHRwSGFuZGxlckZufSBmcm9tICcuL2ludGVyY2VwdG9yJztcbmltcG9ydCB7SHR0cFJlcXVlc3R9IGZyb20gJy4vcmVxdWVzdCc7XG5pbXBvcnQge0h0dHBFdmVudCwgSHR0cFJlc3BvbnNlfSBmcm9tICcuL3Jlc3BvbnNlJztcbmltcG9ydCB7SHR0cFBhcmFtc30gZnJvbSAnLi9wYXJhbXMnO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gY29uZmlndXJlIGhvdyBUcmFuc2ZlckNhY2hlIHNob3VsZCBiZSB1c2VkIHRvIGNhY2hlIHJlcXVlc3RzIG1hZGUgdmlhIEh0dHBDbGllbnQuXG4gKlxuICogQHBhcmFtIGluY2x1ZGVIZWFkZXJzIFNwZWNpZmllcyB3aGljaCBoZWFkZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBpbnRvIGNhY2hlZCByZXNwb25zZXMuIE5vXG4gKiAgICAgaGVhZGVycyBhcmUgaW5jbHVkZWQgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBmaWx0ZXIgQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcmVxdWVzdCBhcyBhbiBhcmd1bWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gdG8gaW5kaWNhdGVcbiAqICAgICB3aGV0aGVyIGEgcmVxdWVzdCBzaG91bGQgYmUgaW5jbHVkZWQgaW50byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0gaW5jbHVkZVBvc3RSZXF1ZXN0cyBFbmFibGVzIGNhY2hpbmcgZm9yIFBPU1QgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIG9ubHkgR0VUIGFuZCBIRUFEXG4gKiAgICAgcmVxdWVzdHMgYXJlIGNhY2hlZC4gVGhpcyBvcHRpb24gY2FuIGJlIGVuYWJsZWQgaWYgUE9TVCByZXF1ZXN0cyBhcmUgdXNlZCB0byByZXRyaWV2ZSBkYXRhXG4gKiAgICAgKGZvciBleGFtcGxlIHVzaW5nIEdyYXBoUUwpLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IHR5cGUgSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zID0ge1xuICBpbmNsdWRlSGVhZGVycz86IHN0cmluZ1tdO1xuICBmaWx0ZXI/OiAocmVxOiBIdHRwUmVxdWVzdDx1bmtub3duPikgPT4gYm9vbGVhbjtcbiAgaW5jbHVkZVBvc3RSZXF1ZXN0cz86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEtleXMgd2l0aGluIGNhY2hlZCByZXNwb25zZSBkYXRhIHN0cnVjdHVyZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgQk9EWSA9ICdiJztcbmV4cG9ydCBjb25zdCBIRUFERVJTID0gJ2gnO1xuZXhwb3J0IGNvbnN0IFNUQVRVUyA9ICdzJztcbmV4cG9ydCBjb25zdCBTVEFUVVNfVEVYVCA9ICdzdCc7XG5leHBvcnQgY29uc3QgVVJMID0gJ3UnO1xuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX1RZUEUgPSAncnQnO1xuXG5pbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICAvKiogYm9keSAqL1xuICBbQk9EWV06IGFueTtcbiAgLyoqIGhlYWRlcnMgKi9cbiAgW0hFQURFUlNdOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT47XG4gIC8qKiBzdGF0dXMgKi9cbiAgW1NUQVRVU10/OiBudW1iZXI7XG4gIC8qKiBzdGF0dXNUZXh0ICovXG4gIFtTVEFUVVNfVEVYVF0/OiBzdHJpbmc7XG4gIC8qKiB1cmwgKi9cbiAgW1VSTF0/OiBzdHJpbmc7XG4gIC8qKiByZXNwb25zZVR5cGUgKi9cbiAgW1JFU1BPTlNFX1RZUEVdPzogSHR0cFJlcXVlc3Q8dW5rbm93bj5bJ3Jlc3BvbnNlVHlwZSddO1xufVxuXG5pbnRlcmZhY2UgQ2FjaGVPcHRpb25zIGV4dGVuZHMgSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zIHtcbiAgaXNDYWNoZUFjdGl2ZTogYm9vbGVhbjtcbn1cblxuY29uc3QgQ0FDSEVfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxDYWNoZU9wdGlvbnM+KFxuICBuZ0Rldk1vZGUgPyAnSFRUUF9UUkFOU0ZFUl9TVEFURV9DQUNIRV9PUFRJT05TJyA6ICcnLFxuKTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsb3dlZCBIVFRQIG1ldGhvZHMgdG8gY2FjaGUuXG4gKi9cbmNvbnN0IEFMTE9XRURfTUVUSE9EUyA9IFsnR0VUJywgJ0hFQUQnXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZmVyQ2FjaGVJbnRlcmNlcHRvckZuKFxuICByZXE6IEh0dHBSZXF1ZXN0PHVua25vd24+LFxuICBuZXh0OiBIdHRwSGFuZGxlckZuLFxuKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8dW5rbm93bj4+IHtcbiAgY29uc3Qge2lzQ2FjaGVBY3RpdmUsIC4uLmdsb2JhbE9wdGlvbnN9ID0gaW5qZWN0KENBQ0hFX09QVElPTlMpO1xuICBjb25zdCB7dHJhbnNmZXJDYWNoZTogcmVxdWVzdE9wdGlvbnMsIG1ldGhvZDogcmVxdWVzdE1ldGhvZH0gPSByZXE7XG5cbiAgLy8gSW4gdGhlIGZvbGxvd2luZyBzaXR1YXRpb25zIHdlIGRvIG5vdCB3YW50IHRvIGNhY2hlIHRoZSByZXF1ZXN0XG4gIGlmIChcbiAgICAhaXNDYWNoZUFjdGl2ZSB8fFxuICAgIC8vIFBPU1QgcmVxdWVzdHMgYXJlIGFsbG93ZWQgZWl0aGVyIGdsb2JhbGx5IG9yIGF0IHJlcXVlc3QgbGV2ZWxcbiAgICAocmVxdWVzdE1ldGhvZCA9PT0gJ1BPU1QnICYmICFnbG9iYWxPcHRpb25zLmluY2x1ZGVQb3N0UmVxdWVzdHMgJiYgIXJlcXVlc3RPcHRpb25zKSB8fFxuICAgIChyZXF1ZXN0TWV0aG9kICE9PSAnUE9TVCcgJiYgIUFMTE9XRURfTUVUSE9EUy5pbmNsdWRlcyhyZXF1ZXN0TWV0aG9kKSkgfHxcbiAgICAvLyBEbyBub3QgY2FjaGUgcmVxdWVzdCB0aGF0IHJlcXVpcmUgYXV0aG9yaXphdGlvblxuICAgIHJlcS5oZWFkZXJzLmhhcygnYXV0aG9yaXphdGlvbicpIHx8XG4gICAgcmVxLmhlYWRlcnMuaGFzKCdwcm94eS1hdXRob3JpemF0aW9uJykgfHxcbiAgICByZXF1ZXN0T3B0aW9ucyA9PT0gZmFsc2UgfHxcbiAgICBnbG9iYWxPcHRpb25zLmZpbHRlcj8uKHJlcSkgPT09IGZhbHNlXG4gICkge1xuICAgIHJldHVybiBuZXh0KHJlcSk7XG4gIH1cblxuICBjb25zdCB0cmFuc2ZlclN0YXRlID0gaW5qZWN0KFRyYW5zZmVyU3RhdGUpO1xuICBjb25zdCBzdG9yZUtleSA9IG1ha2VDYWNoZUtleShyZXEpO1xuICBjb25zdCByZXNwb25zZSA9IHRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCBudWxsKTtcblxuICBsZXQgaGVhZGVyc1RvSW5jbHVkZSA9IGdsb2JhbE9wdGlvbnMuaW5jbHVkZUhlYWRlcnM7XG4gIGlmICh0eXBlb2YgcmVxdWVzdE9wdGlvbnMgPT09ICdvYmplY3QnICYmIHJlcXVlc3RPcHRpb25zLmluY2x1ZGVIZWFkZXJzKSB7XG4gICAgLy8gUmVxdWVzdC1zcGVjaWZpYyBjb25maWcgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBnbG9iYWwgY29uZmlnLlxuICAgIGhlYWRlcnNUb0luY2x1ZGUgPSByZXF1ZXN0T3B0aW9ucy5pbmNsdWRlSGVhZGVycztcbiAgfVxuXG4gIGlmIChyZXNwb25zZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFtCT0RZXTogdW5kZWNvZGVkQm9keSxcbiAgICAgIFtSRVNQT05TRV9UWVBFXTogcmVzcG9uc2VUeXBlLFxuICAgICAgW0hFQURFUlNdOiBodHRwSGVhZGVycyxcbiAgICAgIFtTVEFUVVNdOiBzdGF0dXMsXG4gICAgICBbU1RBVFVTX1RFWFRdOiBzdGF0dXNUZXh0LFxuICAgICAgW1VSTF06IHVybCxcbiAgICB9ID0gcmVzcG9uc2U7XG4gICAgLy8gUmVxdWVzdCBmb3VuZCBpbiBjYWNoZS4gUmVzcG9uZCB1c2luZyBpdC5cbiAgICBsZXQgYm9keTogQXJyYXlCdWZmZXIgfCBCbG9iIHwgc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWNvZGVkQm9keTtcblxuICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgIGJvZHkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodW5kZWNvZGVkQm9keSkuYnVmZmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICBib2R5ID0gbmV3IEJsb2IoW3VuZGVjb2RlZEJvZHldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2FudCB0byB3YXJuIHVzZXJzIGFjY2Vzc2luZyBhIGhlYWRlciBwcm92aWRlZCBmcm9tIHRoZSBjYWNoZVxuICAgIC8vIFRoYXQgSHR0cFRyYW5zZmVyQ2FjaGUgYWx0ZXJzIHRoZSBoZWFkZXJzXG4gICAgLy8gVGhlIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQgYSBzaW5nbGUgdGltZSBieSBIdHRwSGVhZGVycyBpbnN0YW5jZVxuICAgIGxldCBoZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKGh0dHBIZWFkZXJzKTtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAvLyBBcHBlbmQgZXh0cmEgbG9naWMgaW4gZGV2IG1vZGUgdG8gcHJvZHVjZSBhIHdhcm5pbmcgd2hlbiBhIGhlYWRlclxuICAgICAgLy8gdGhhdCB3YXMgbm90IHRyYW5zZmVycmVkIHRvIHRoZSBjbGllbnQgaXMgYWNjZXNzZWQgaW4gdGhlIGNvZGUgdmlhIGBnZXRgXG4gICAgICAvLyBhbmQgYGhhc2AgY2FsbHMuXG4gICAgICBoZWFkZXJzID0gYXBwZW5kTWlzc2luZ0hlYWRlcnNEZXRlY3Rpb24ocmVxLnVybCwgaGVhZGVycywgaGVhZGVyc1RvSW5jbHVkZSA/PyBbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mKFxuICAgICAgbmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgcmV0dXJuIG5leHQocmVxKS5waXBlKFxuICAgIHRhcCgoZXZlbnQ6IEh0dHBFdmVudDx1bmtub3duPikgPT4ge1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgIHRyYW5zZmVyU3RhdGUuc2V0PFRyYW5zZmVySHR0cFJlc3BvbnNlPihzdG9yZUtleSwge1xuICAgICAgICAgIFtCT0RZXTogZXZlbnQuYm9keSxcbiAgICAgICAgICBbSEVBREVSU106IGdldEZpbHRlcmVkSGVhZGVycyhldmVudC5oZWFkZXJzLCBoZWFkZXJzVG9JbmNsdWRlKSxcbiAgICAgICAgICBbU1RBVFVTXTogZXZlbnQuc3RhdHVzLFxuICAgICAgICAgIFtTVEFUVVNfVEVYVF06IGV2ZW50LnN0YXR1c1RleHQsXG4gICAgICAgICAgW1VSTF06IGV2ZW50LnVybCB8fCAnJyxcbiAgICAgICAgICBbUkVTUE9OU0VfVFlQRV06IHJlcS5yZXNwb25zZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJlZEhlYWRlcnMoXG4gIGhlYWRlcnM6IEh0dHBIZWFkZXJzLFxuICBpbmNsdWRlSGVhZGVyczogc3RyaW5nW10gfCB1bmRlZmluZWQsXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4ge1xuICBpZiAoIWluY2x1ZGVIZWFkZXJzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgaGVhZGVyc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgY29uc3QgdmFsdWVzID0gaGVhZGVycy5nZXRBbGwoa2V5KTtcbiAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICBoZWFkZXJzTWFwW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNNYXA7XG59XG5cbmZ1bmN0aW9uIHNvcnRBbmRDb25jYXRQYXJhbXMocGFyYW1zOiBIdHRwUGFyYW1zIHwgVVJMU2VhcmNoUGFyYW1zKTogc3RyaW5nIHtcbiAgcmV0dXJuIFsuLi5wYXJhbXMua2V5cygpXVxuICAgIC5zb3J0KClcbiAgICAubWFwKChrKSA9PiBgJHtrfT0ke3BhcmFtcy5nZXRBbGwoayl9YClcbiAgICAuam9pbignJicpO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2FjaGVLZXkocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IFN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPiB7XG4gIC8vIG1ha2UgdGhlIHBhcmFtcyBlbmNvZGVkIHNhbWUgYXMgYSB1cmwgc28gaXQncyBlYXN5IHRvIGlkZW50aWZ5XG4gIGNvbnN0IHtwYXJhbXMsIG1ldGhvZCwgcmVzcG9uc2VUeXBlLCB1cmx9ID0gcmVxdWVzdDtcbiAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IHNvcnRBbmRDb25jYXRQYXJhbXMocGFyYW1zKTtcblxuICBsZXQgc2VyaWFsaXplZEJvZHkgPSByZXF1ZXN0LnNlcmlhbGl6ZUJvZHkoKTtcbiAgaWYgKHNlcmlhbGl6ZWRCb2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VyaWFsaXplZEJvZHkgPSBzb3J0QW5kQ29uY2F0UGFyYW1zKHNlcmlhbGl6ZWRCb2R5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VyaWFsaXplZEJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgc2VyaWFsaXplZEJvZHkgPSAnJztcbiAgfVxuXG4gIGNvbnN0IGtleSA9IFttZXRob2QsIHJlc3BvbnNlVHlwZSwgdXJsLCBzZXJpYWxpemVkQm9keSwgZW5jb2RlZFBhcmFtc10uam9pbignfCcpO1xuICBjb25zdCBoYXNoID0gZ2VuZXJhdGVIYXNoKGtleSk7XG5cbiAgcmV0dXJuIG1ha2VTdGF0ZUtleShoYXNoKTtcbn1cblxuLyoqXG4gKiBBIG1ldGhvZCB0aGF0IHJldHVybnMgYSBoYXNoIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RyaW5nIHVzaW5nIGEgdmFyaWFudCBvZiBESkIyIGhhc2hcbiAqIGFsZ29yaXRobS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGhhc2hpbmcgbG9naWMgdGhhdCBpcyB1c2VkIHRvIGdlbmVyYXRlIGNvbXBvbmVudCBpZHMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSGFzaCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IGhhc2ggPSAwO1xuXG4gIGZvciAoY29uc3QgY2hhciBvZiB2YWx1ZSkge1xuICAgIGhhc2ggPSAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGNoYXIuY2hhckNvZGVBdCgwKSkgPDwgMDtcbiAgfVxuXG4gIC8vIEZvcmNlIHBvc2l0aXZlIG51bWJlciBoYXNoLlxuICAvLyAyMTQ3NDgzNjQ3ID0gZXF1aXZhbGVudCBvZiBJbnRlZ2VyLk1BWF9WQUxVRS5cbiAgaGFzaCArPSAyMTQ3NDgzNjQ3ICsgMTtcblxuICByZXR1cm4gaGFzaC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIERJIHByb3ZpZGVycyBuZWVkZWQgdG8gZW5hYmxlIEhUVFAgdHJhbnNmZXIgY2FjaGUuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nLCByZXF1ZXN0cyBhcmUgcGVyZm9ybWVkIHR3aWNlOiBvbmNlIG9uIHRoZSBzZXJ2ZXIgYW5kXG4gKiBvdGhlciBvbmUgb24gdGhlIGJyb3dzZXIuXG4gKlxuICogV2hlbiB0aGVzZSBwcm92aWRlcnMgYXJlIGFkZGVkLCByZXF1ZXN0cyBwZXJmb3JtZWQgb24gdGhlIHNlcnZlciBhcmUgY2FjaGVkIGFuZCByZXVzZWQgZHVyaW5nIHRoZVxuICogYm9vdHN0cmFwcGluZyBvZiB0aGUgYXBwbGljYXRpb24gaW4gdGhlIGJyb3dzZXIgdGh1cyBhdm9pZGluZyBkdXBsaWNhdGUgcmVxdWVzdHMgYW5kIHJlZHVjaW5nXG4gKiBsb2FkIHRpbWUuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEh0dHBUcmFuc2ZlckNhY2hlKGNhY2hlT3B0aW9uczogSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zKTogUHJvdmlkZXJbXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogQ0FDSEVfT1BUSU9OUyxcbiAgICAgIHVzZUZhY3Rvcnk6ICgpOiBDYWNoZU9wdGlvbnMgPT4ge1xuICAgICAgICBwZXJmb3JtYW5jZU1hcmtGZWF0dXJlKCdOZ0h0dHBUcmFuc2ZlckNhY2hlJyk7XG4gICAgICAgIHJldHVybiB7aXNDYWNoZUFjdGl2ZTogdHJ1ZSwgLi4uY2FjaGVPcHRpb25zfTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBIVFRQX1JPT1RfSU5URVJDRVBUT1JfRk5TLFxuICAgICAgdXNlVmFsdWU6IHRyYW5zZmVyQ2FjaGVJbnRlcmNlcHRvckZuLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgICBkZXBzOiBbVHJhbnNmZXJTdGF0ZSwgQ0FDSEVfT1BUSU9OU10sXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgICB1c2VGYWN0b3J5OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcFJlZiA9IGluamVjdChBcHBsaWNhdGlvblJlZik7XG4gICAgICAgIGNvbnN0IGNhY2hlU3RhdGUgPSBpbmplY3QoQ0FDSEVfT1BUSU9OUyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB3aGVuU3RhYmxlKGFwcFJlZikudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZVN0YXRlLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfSxcbiAgXTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGEgcHJveHkgdG8gYW4gSHR0cEhlYWRlciB0byBpbnRlcmNlcHQgY2FsbHMgdG8gZ2V0L2hhc1xuICogYW5kIGxvZyBhIHdhcm5pbmcgaWYgdGhlIGhlYWRlciBlbnRyeSByZXF1ZXN0ZWQgaGFzIGJlZW4gcmVtb3ZlZFxuICovXG5mdW5jdGlvbiBhcHBlbmRNaXNzaW5nSGVhZGVyc0RldGVjdGlvbihcbiAgdXJsOiBzdHJpbmcsXG4gIGhlYWRlcnM6IEh0dHBIZWFkZXJzLFxuICBoZWFkZXJzVG9JbmNsdWRlOiBzdHJpbmdbXSxcbik6IEh0dHBIZWFkZXJzIHtcbiAgY29uc3Qgd2FybmluZ1Byb2R1Y2VkID0gbmV3IFNldCgpO1xuICByZXR1cm4gbmV3IFByb3h5PEh0dHBIZWFkZXJzPihoZWFkZXJzLCB7XG4gICAgZ2V0KHRhcmdldDogSHR0cEhlYWRlcnMsIHByb3A6IGtleW9mIEh0dHBIZWFkZXJzKTogdW5rbm93biB7XG4gICAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG4gICAgICBjb25zdCBtZXRob2RzOiBTZXQ8a2V5b2YgSHR0cEhlYWRlcnM+ID0gbmV3IFNldChbJ2dldCcsICdoYXMnLCAnZ2V0QWxsJ10pO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8ICFtZXRob2RzLmhhcyhwcm9wKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoaGVhZGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFdlIGxvZyB3aGVuIHRoZSBrZXkgaGFzIGJlZW4gcmVtb3ZlZCBhbmQgYSB3YXJuaW5nIGhhc24ndCBiZWVuIHByb2R1Y2VkIGZvciB0aGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IGtleSA9IChwcm9wICsgJzonICsgaGVhZGVyTmFtZSkudG9Mb3dlckNhc2UoKTsgLy8gZS5nLiBgZ2V0OmNhY2hlLWNvbnRyb2xgXG4gICAgICAgIGlmICghaGVhZGVyc1RvSW5jbHVkZS5pbmNsdWRlcyhoZWFkZXJOYW1lKSAmJiAhd2FybmluZ1Byb2R1Y2VkLmhhcyhrZXkpKSB7XG4gICAgICAgICAgd2FybmluZ1Byb2R1Y2VkLmFkZChrZXkpO1xuICAgICAgICAgIGNvbnN0IHRydW5jYXRlZFVybCA9IHRydW5jYXRlTWlkZGxlKHVybCk7XG5cbiAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgRXJyb3IgZ3VpZGUgZm9yIHRoaXMgd2FybmluZ1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGZvcm1hdFJ1bnRpbWVFcnJvcihcbiAgICAgICAgICAgICAgUnVudGltZUVycm9yQ29kZS5IRUFERVJTX0FMVEVSRURfQllfVFJBTlNGRVJfQ0FDSEUsXG4gICAgICAgICAgICAgIGBBbmd1bGFyIGRldGVjdGVkIHRoYXQgdGhlIFxcYCR7aGVhZGVyTmFtZX1cXGAgaGVhZGVyIGlzIGFjY2Vzc2VkLCBidXQgdGhlIHZhbHVlIG9mIHRoZSBoZWFkZXIgYCArXG4gICAgICAgICAgICAgICAgYHdhcyBub3QgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgYnkgdGhlIEh0dHBUcmFuc2ZlckNhY2hlLiBgICtcbiAgICAgICAgICAgICAgICBgVG8gaW5jbHVkZSB0aGUgdmFsdWUgb2YgdGhlIFxcYCR7aGVhZGVyTmFtZX1cXGAgaGVhZGVyIGZvciB0aGUgXFxgJHt0cnVuY2F0ZWRVcmx9XFxgIHJlcXVlc3QsIGAgK1xuICAgICAgICAgICAgICAgIGB1c2UgdGhlIFxcYGluY2x1ZGVIZWFkZXJzXFxgIGxpc3QuIFRoZSBcXGBpbmNsdWRlSGVhZGVyc1xcYCBjYW4gYmUgZGVmaW5lZCBlaXRoZXIgYCArXG4gICAgICAgICAgICAgICAgYG9uIGEgcmVxdWVzdCBsZXZlbCBieSBhZGRpbmcgdGhlIFxcYHRyYW5zZmVyQ2FjaGVcXGAgcGFyYW1ldGVyLCBvciBvbiBhbiBhcHBsaWNhdGlvbiBgICtcbiAgICAgICAgICAgICAgICBgbGV2ZWwgYnkgYWRkaW5nIHRoZSBcXGBodHRwQ2FjaGVUcmFuc2Zlci5pbmNsdWRlSGVhZGVyc1xcYCBhcmd1bWVudCB0byB0aGUgYCArXG4gICAgICAgICAgICAgICAgYFxcYHByb3ZpZGVDbGllbnRIeWRyYXRpb24oKVxcYCBjYWxsLiBgLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52b2tpbmcgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICByZXR1cm4gKHZhbHVlIGFzIEZ1bmN0aW9uKS5hcHBseSh0YXJnZXQsIFtoZWFkZXJOYW1lXSk7XG4gICAgICB9O1xuICAgIH0sXG4gIH0pO1xufVxuIl19