{"version":3,"file":"http.js","sources":["../../../../../packages/common/http/index.ts","../../../../../packages/common/http/public_api.ts","../../../../../packages/common/http/src/module.ts","../../../../../packages/common/http/src/xsrf.ts","../../../../../packages/common/http/src/xhr.ts","../../../../../packages/common/http/src/jsonp.ts","../../../../../packages/common/http/src/interceptor.ts","../../../../../packages/common/http/src/client.ts","../../../../../packages/common/http/src/response.ts","../../../../../packages/common/http/src/request.ts","../../../../../packages/common/http/src/headers.ts","../../../../../packages/common/http/src/params.ts","../../../../../packages/common/http/src/backend.ts"],"sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport {HttpBackend,HttpHandler,HttpClient,HttpHeaders,HTTP_INTERCEPTORS,HttpInterceptor,JsonpClientBackend,JsonpInterceptor,HttpClientJsonpModule,HttpClientModule,HttpClientXsrfModule,ɵinterceptingHandler,HttpParameterCodec,HttpParams,HttpUrlEncodingCodec,HttpRequest,HttpDownloadProgressEvent,HttpErrorResponse,HttpEvent,HttpEventType,HttpHeaderResponse,HttpProgressEvent,HttpResponse,HttpResponseBase,HttpSentEvent,HttpUserEvent,HttpXhrBackend,XhrFactory,HttpXsrfTokenExtractor} from './public_api';\n\nexport {NoopInterceptor as ɵa} from './src/interceptor';\nexport {JsonpCallbackContext as ɵb} from './src/jsonp';\nexport {jsonpCallbackContext as ɵc} from './src/module';\nexport {BrowserXhr as ɵd} from './src/xhr';\nexport {HttpXsrfCookieExtractor as ɵg,HttpXsrfInterceptor as ɵh,XSRF_COOKIE_NAME as ɵe,XSRF_HEADER_NAME as ɵf} from './src/xsrf';","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {HttpBackend, HttpHandler} from './src/backend';\nexport {HttpClient} from './src/client';\nexport {HttpHeaders} from './src/headers';\nexport {HTTP_INTERCEPTORS, HttpInterceptor} from './src/interceptor';\nexport {JsonpClientBackend, JsonpInterceptor} from './src/jsonp';\nexport {HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, interceptingHandler as ɵinterceptingHandler} from './src/module';\nexport {HttpParameterCodec, HttpParams, HttpUrlEncodingCodec} from './src/params';\nexport {HttpRequest} from './src/request';\nexport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpProgressEvent, HttpResponse, HttpResponseBase, HttpSentEvent, HttpUserEvent} from './src/response';\nexport {HttpXhrBackend, XhrFactory} from './src/xhr';\nexport {HttpXsrfTokenExtractor} from './src/xsrf';\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, ModuleWithProviders, NgModule, Optional} from '@angular/core';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpClient} from './client';\nimport {HTTP_INTERCEPTORS, HttpInterceptor, HttpInterceptorHandler, NoopInterceptor} from './interceptor';\nimport {JsonpCallbackContext, JsonpClientBackend, JsonpInterceptor} from './jsonp';\nimport {BrowserXhr, HttpXhrBackend, XhrFactory} from './xhr';\nimport {HttpXsrfCookieExtractor, HttpXsrfInterceptor, HttpXsrfTokenExtractor, XSRF_COOKIE_NAME, XSRF_HEADER_NAME} from './xsrf';\n/**\n * Constructs an `HttpHandler` that applies a bunch of `HttpInterceptor`s\n * to a request before passing it to the given `HttpBackend`.\n * \n * Meant to be used as a factory function within `HttpClientModule`.\n * \n * \\@experimental\n * @param {?} backend\n * @param {?=} interceptors\n * @return {?}\n */\nexport function interceptingHandler(\n    backend: HttpBackend, interceptors: HttpInterceptor[] | null = []): HttpHandler {\n  if (!interceptors) {\n    return backend;\n  }\n  return interceptors.reduceRight(\n      (next, interceptor) => new HttpInterceptorHandler(next, interceptor), backend);\n}\n/**\n * Factory function that determines where to store JSONP callbacks.\n * \n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n * \n * \\@experimental\n * @return {?}\n */\nexport function jsonpCallbackContext(): Object {\n  if (typeof window === 'object') {\n    return window;\n  }\n  return {};\n}\n/**\n * `NgModule` which adds XSRF protection support to outgoing requests.\n * \n * Provided the server supports a cookie-based XSRF protection system, this\n * module can be used directly to configure XSRF protection with the correct\n * cookie and header names.\n * \n * If no such names are provided, the default is to use `X-XSRF-TOKEN` for\n * the header name and `XSRF-TOKEN` for the cookie name.\n * \n * \\@experimental\n */\nexport class HttpClientXsrfModule {\n/**\n * Disable the default XSRF protection.\n * @return {?}\n */\nstatic disable(): ModuleWithProviders {\n    return {\n      ngModule: HttpClientXsrfModule,\n      providers: [\n        {provide: HttpXsrfInterceptor, useClass: NoopInterceptor},\n      ],\n    };\n  }\n/**\n * Configure XSRF protection to use the given cookie name or header name,\n * or the default names (as described above) if not provided.\n * @param {?=} options\n * @return {?}\n */\nstatic withOptions(options: {\n    cookieName?: string,\n    headerName?: string,\n  } = {}): ModuleWithProviders {\n    return {\n      ngModule: HttpClientXsrfModule,\n      providers: [\n        options.cookieName ? {provide: XSRF_COOKIE_NAME, useValue: options.cookieName} : [],\n        options.headerName ? {provide: XSRF_HEADER_NAME, useValue: options.headerName} : [],\n      ],\n    };\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: NgModule, args: [{\n  providers: [\n    HttpXsrfInterceptor,\n    {provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true},\n    {provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor},\n    {provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN'},\n    {provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN'},\n  ],\n}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction HttpClientXsrfModule_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClientXsrfModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClientXsrfModule.ctorParameters;\n}\n\n/**\n * `NgModule` which provides the `HttpClient` and associated services.\n * \n * Interceptors can be added to the chain behind `HttpClient` by binding them\n * to the multiprovider for `HTTP_INTERCEPTORS`.\n * \n * \\@experimental\n */\nexport class HttpClientModule {\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: NgModule, args: [{\n  imports: [\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-XSRF-TOKEN',\n    }),\n  ],\n  providers: [\n    HttpClient,\n    // HttpHandler is the backend + interceptors and is constructed\n    // using the interceptingHandler factory function.\n    {\n      provide: HttpHandler,\n      useFactory: interceptingHandler,\n      deps: [HttpBackend, [new Optional(), new Inject(HTTP_INTERCEPTORS)]],\n    },\n    HttpXhrBackend,\n    {provide: HttpBackend, useExisting: HttpXhrBackend},\n    BrowserXhr,\n    {provide: XhrFactory, useExisting: BrowserXhr},\n  ],\n}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction HttpClientModule_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClientModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClientModule.ctorParameters;\n}\n\n/**\n * `NgModule` which enables JSONP support in `HttpClient`.\n * \n * Without this module, Jsonp requests will reach the backend\n * with method JSONP, where they'll be rejected.\n * \n * \\@experimental\n */\nexport class HttpClientJsonpModule {\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: NgModule, args: [{\n  providers: [\n    JsonpClientBackend,\n    {provide: JsonpCallbackContext, useFactory: jsonpCallbackContext},\n    {provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true},\n  ],\n}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction HttpClientJsonpModule_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClientJsonpModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClientJsonpModule.ctorParameters;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ɵparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, PLATFORM_ID} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\n\nimport {HttpHandler} from './backend';\nimport {HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const /** @type {?} */ XSRF_COOKIE_NAME = new InjectionToken<string>('XSRF_COOKIE_NAME');\nexport const /** @type {?} */ XSRF_HEADER_NAME = new InjectionToken<string>('XSRF_HEADER_NAME');\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string|null;\n}\n\nfunction HttpXsrfTokenExtractor_tsickle_Closure_declarations() {\n\n/**\n * Get the XSRF token to use with an outgoing request.\n * \n * Will be called for every request, so the token may change between requests.\n * @abstract\n * @return {?}\n */\nHttpXsrfTokenExtractor.prototype.getToken = function() {};\n}\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\nprivate lastCookieString: string = '';\nprivate lastToken: string|null = null;\n/**\n * \\@internal for testing\n */\nparseCount: number = 0;\n/**\n * @param {?} doc\n * @param {?} platform\n * @param {?} cookieName\n */\nconstructor(\nprivate doc: any,\nprivate platform: string,\nprivate cookieName: string) {}\n/**\n * @return {?}\n */\ngetToken(): string|null {\n    if (this.platform === 'server') {\n      return null;\n    }\n    const /** @type {?} */ cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n{type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID, ] }, ]},\n{type: undefined, decorators: [{ type: Inject, args: [XSRF_COOKIE_NAME, ] }, ]},\n];\n}\n\nfunction HttpXsrfCookieExtractor_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXsrfCookieExtractor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXsrfCookieExtractor.ctorParameters;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.lastCookieString;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.lastToken;\n/**\n * \\@internal for testing\n * @type {?}\n */\nHttpXsrfCookieExtractor.prototype.parseCount;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.doc;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.platform;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.cookieName;\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n/**\n * @param {?} tokenService\n * @param {?} headerName\n */\nconstructor(\nprivate tokenService: HttpXsrfTokenExtractor,\nprivate headerName: string) {}\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const /** @type {?} */ lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n        lcUrl.startsWith('https://')) {\n      return next.handle(req);\n    }\n    const /** @type {?} */ token = this.tokenService.getToken();\n\n    // Be careful not to overwrite an existing header of the same name.\n    if (token !== null && !req.headers.has(this.headerName)) {\n      req = req.clone({headers: req.headers.set(this.headerName, token)});\n    }\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: HttpXsrfTokenExtractor, },\n{type: undefined, decorators: [{ type: Inject, args: [XSRF_HEADER_NAME, ] }, ]},\n];\n}\n\nfunction HttpXsrfInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXsrfInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXsrfInterceptor.ctorParameters;\n/** @type {?} */\nHttpXsrfInterceptor.prototype.tokenService;\n/** @type {?} */\nHttpXsrfInterceptor.prototype.headerName;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpRequest} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpUploadProgressEvent} from './response';\n\nconst /** @type {?} */ XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n * @param {?} xhr\n * @return {?}\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class XhrFactory { abstract build(): XMLHttpRequest; }\n\nfunction XhrFactory_tsickle_Closure_declarations() {\n\n/**\n * @abstract\n * @return {?}\n */\nXhrFactory.prototype.build = function() {};\n}\n\n/**\n * A factory for \\@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n * \n * \\@experimental\n */\nexport class BrowserXhr implements XhrFactory {\nconstructor() {}\n/**\n * @return {?}\n */\nbuild(): any { return /** @type {?} */(( <any>(new XMLHttpRequest()))); }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction BrowserXhr_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserXhr.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserXhr.ctorParameters;\n}\n\n/**\n * Tracks a response from the server that does not yet have a body.\n * @record\n */\nfunction PartialResponse() {}\n\n\nfunction PartialResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nPartialResponse.prototype.headers;\n/** @type {?} */\nPartialResponse.prototype.status;\n/** @type {?} */\nPartialResponse.prototype.statusText;\n/** @type {?} */\nPartialResponse.prototype.url;\n}\n\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n * \n * \\@experimental\n */\nexport class HttpXhrBackend implements HttpBackend {\n/**\n * @param {?} xhrFactory\n */\nconstructor(private xhrFactory: XhrFactory) {}\n/**\n * Process a request and return a stream of response events.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const /** @type {?} */ xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.urlWithParams);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const /** @type {?} */ detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        xhr.responseType = /** @type {?} */(( req.responseType.toLowerCase() as any));\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const /** @type {?} */ reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let /** @type {?} */ headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const /** @type {?} */ partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const /** @type {?} */ status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const /** @type {?} */ statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const /** @type {?} */ headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const /** @type {?} */ url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const /** @type {?} */ onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let /** @type {?} */ body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n\n          // Strip a common XSSI prefix from string responses.\n          // TODO: determine if this behavior should be optional and moved to an interceptor.\n          if (typeof body === 'string') {\n            body = body.replace(XSSI_PREFIX, '');\n          }\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let /** @type {?} */ ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (ok && typeof body === 'string' && req.responseType === 'json') {\n          // Attempt the parse. If it fails, a parse error should be delivered to the user.\n          try {\n            body = JSON.parse(body);\n          } catch ( /** @type {?} */error) {\n            // Even though the response status was 2xx, this is still an error.\n            ok = false;\n            // The parse error contains the text of the body that failed to parse.\n            body = /** @type {?} */(( { error, text: body } as HttpJsonParseError));\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const /** @type {?} */ onError = (error: ErrorEvent) => {\n        const /** @type {?} */ res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let /** @type {?} */ sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let /** @type {?} */ progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onUpProgress = (event: ProgressEvent) => {\n        // Upload progress events are simpler. Begin building the progress\n        // event.\n        let /** @type {?} */ progress: HttpUploadProgressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded: event.loaded,\n        };\n\n        // If the total number of bytes being uploaded is available, include\n        // it.\n        if (event.lengthComputable) {\n          progress.total = event.total;\n        }\n\n        // Send the event.\n        observer.next(progress);\n      };\n\n      // By default, register for load and error events.\n      xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: XhrFactory, },\n];\n}\n\nfunction HttpXhrBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXhrBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXhrBackend.ctorParameters;\n/** @type {?} */\nHttpXhrBackend.prototype.xhrFactory;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet /** @type {?} */ nextRequestId: number = 0;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const /** @type {?} */ JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const /** @type {?} */ JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const /** @type {?} */ JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n * \n * In the browser, this should always be the `window` object.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class JsonpCallbackContext { [key: string]: (data: any) => void; }\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * \n * \\@experimental\n */\nexport class JsonpClientBackend implements HttpBackend {\n/**\n * @param {?} callbackMap\n * @param {?} document\n */\nconstructor(private callbackMap: JsonpCallbackContext,\nprivate document: any) {}\n/**\n * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n * @return {?}\n */\n\nprivate nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n/**\n * Process a JSONP request and return an event stream of the results.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const /** @type {?} */ callback = this.nextCallback();\n      const /** @type {?} */ url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const /** @type {?} */ node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let /** @type {?} */ body: any|null = null;\n\n      // Whether the response callback has been called.\n      let /** @type {?} */ finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let /** @type {?} */ cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const /** @type {?} */ cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const /** @type {?} */ onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the resposne is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const /** @type {?} */ onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: JsonpCallbackContext, },\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n];\n}\n\nfunction JsonpClientBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpClientBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpClientBackend.ctorParameters;\n/** @type {?} */\nJsonpClientBackend.prototype.callbackMap;\n/** @type {?} */\nJsonpClientBackend.prototype.document;\n}\n\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n * \n * \\@experimental\n */\nexport class JsonpInterceptor {\n/**\n * @param {?} jsonp\n */\nconstructor(private jsonp: JsonpClientBackend) {}\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle( /** @type {?} */((req as HttpRequest<never>)));\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: JsonpClientBackend, },\n];\n}\n\nfunction JsonpInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpInterceptor.ctorParameters;\n/** @type {?} */\nJsonpInterceptor.prototype.jsonp;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\n\nimport {HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n/**\n * Intercepts `HttpRequest` and handles them.\n * \n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n * \n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n * \n * \\@experimental\n * @record\n */\nexport function HttpInterceptor() {}\n\n\nfunction HttpInterceptor_tsickle_Closure_declarations() {\n/**\n * Intercept an outgoing `HttpRequest` and optionally transform it or the\n * response.\n * \n * Typically an interceptor will transform the outgoing request before returning\n * `next.handle(transformedReq)`. An interceptor may choose to transform the\n * response event stream as well, by applying additional Rx operators on the stream\n * returned by `next.handle()`.\n * \n * More rarely, an interceptor may choose to completely handle the request itself,\n * and compose a new event stream instead of invoking `next.handle()`. This is\n * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n * \n * It is also rare but valid for an interceptor to return multiple responses on the\n * event stream for a single request.\n * @type {?}\n */\nHttpInterceptor.prototype.intercept;\n}\n\n\n/**\n * Intercepts `HttpRequest` and handles them.\n *\n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n *\n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n *\n * @experimental\n */\nexport interface HttpInterceptor {\n  /**\n   * Intercept an outgoing `HttpRequest` and optionally transform it or the\n   * response.\n   *\n   * Typically an interceptor will transform the outgoing request before returning\n   * `next.handle(transformedReq)`. An interceptor may choose to transform the\n   * response event stream as well, by applying additional Rx operators on the stream\n   * returned by `next.handle()`.\n   *\n   * More rarely, an interceptor may choose to completely handle the request itself,\n   * and compose a new event stream instead of invoking `next.handle()`. This is\n   * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n   *\n   * It is also rare but valid for an interceptor to return multiple responses on the\n   * event stream for a single request.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n * \n * \\@experimental\n */\nexport class HttpInterceptorHandler implements HttpHandler {\n/**\n * @param {?} next\n * @param {?} interceptor\n */\nconstructor(private next: HttpHandler,\nprivate interceptor: HttpInterceptor) {}\n/**\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return this.interceptor.intercept(req, this.next);\n  }\n}\n\nfunction HttpInterceptorHandler_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpInterceptorHandler.prototype.next;\n/** @type {?} */\nHttpInterceptorHandler.prototype.interceptor;\n}\n\n/**\n * A multi-provider token which represents the array of `HttpInterceptor`s that\n * are registered.\n * \n * \\@experimental\n */\nexport const /** @type {?} */ HTTP_INTERCEPTORS = new InjectionToken<HttpInterceptor[]>('HTTP_INTERCEPTORS');\nexport class NoopInterceptor implements HttpInterceptor {\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction NoopInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNoopInterceptor.ctorParameters;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {of } from 'rxjs/observable/of';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {filter} from 'rxjs/operator/filter';\nimport {map} from 'rxjs/operator/map';\n\nimport {HttpHandler} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\nimport {HttpRequest} from './request';\nimport {HttpEvent, HttpResponse} from './response';\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n * @template T\n * @param {?} options\n * @param {?} body\n * @return {?}\n */\nfunction addBody<T>(\n    options: {\n      headers?: HttpHeaders,\n      observe?: HttpObserve,\n      params?: HttpParams,\n      reportProgress?: boolean,\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n      withCredentials?: boolean,\n    },\n    body: T | null): any {\n  return {\n    body,\n    headers: options.headers,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n  };\n}\n\n/**\n * @experimental\n */\nexport type HttpObserve = 'body' | 'events' | 'response';\n/**\n * Perform HTTP requests.\n * \n * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies according to which\n * signature is called (mainly the values of `observe` and `responseType`).\n * \n * \\@experimental\n */\nexport class HttpClient {\n/**\n * @param {?} handler\n */\nconstructor(private handler: HttpHandler) {}\n\n  /**\n   * Send the given `HttpRequest` and return a stream of `HttpEvents`.\n   */\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    params?: HttpParams,\n    observe: 'events', reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as an `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'events', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<any>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'events', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'response', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'response', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpResponse<R>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<R>;\n\n  /**\n   * Construct a request in a manner where response type and requested `Observable` are not known\n   * statically.\n   *\n   * @return an `Observable` of whatever was requested, typed to `any`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    params?: HttpParams,\n    observe?: HttpObserve,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  }): Observable<any>;\n/**\n * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n * fires the request through the chain of registered interceptors and on to the\n * server.\n * \n * This method can be called in one of two ways. Either an `HttpRequest`\n * instance can be passed directly as the only parameter, or a method can be\n * passed as the first parameter, a string URL as the second, and an\n * options hash as the third.\n * \n * If a `HttpRequest` object is passed directly, an `Observable` of the\n * raw `HttpEvent` stream will be returned.\n * \n * If a request is instead built by providing a URL, the options object\n * determines the return type of `request()`. In addition to configuring\n * request parameters such as the outgoing headers and/or the body, the options\n * hash specifies two key pieces of information about the request: the\n * `responseType` and what to `observe`.\n * \n * The `responseType` value determines how a successful response body will be\n * parsed. If `responseType` is the default `json`, a type interface for the\n * resulting object may be passed as a type parameter to `request()`.\n * \n * The `observe` value determines the return type of `request()`, based on what\n * the consumer is interested in observing. A value of `events` will return an\n * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,\n * including progress events by default. A value of `response` will return an\n * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`\n * depends on the `responseType` and any optionally provided type parameter.\n * A value of `body` will return an `Observable<T>` with the same `T` body type.\n * @param {?} first\n * @param {?=} url\n * @param {?=} options\n * @return {?}\n */\nrequest(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let /** @type {?} */ req: HttpRequest<any>;\n    // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = /** @type {?} */(( first as HttpRequest<any>));\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming GET unless a method is\n      // provided.\n      req = new HttpRequest(first, /** @type {?} */(( url)), options.body || null, {\n        headers: options.headers,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const /** @type {?} */ events$: Observable<HttpEvent<any>> =\n        concatMap.call(of (req), (req: HttpRequest<any>) => this.handler.handle(req));\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const /** @type {?} */ res$: Observable<HttpResponse<any>> =\n        filter.call(events$, (event: HttpEvent<any>) => event instanceof HttpResponse);\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is an ArrayBuffer.\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new Error('Response is not an ArrayBuffer.');\n              }\n              return res.body;\n            });\n          case 'blob':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a Blob.\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new Error('Response is not a Blob.');\n              }\n              return res.body;\n            });\n          case 'text':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a string.\n              if (res.body !== null && typeof res.body !== 'string') {\n                throw new Error('Response is not a string.');\n              }\n              return res.body;\n            });\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return map.call(res$, (res: HttpResponse<any>) => res.body);\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  delete (url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  delete<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * DELETE request to be executed on the server. See the individual overloads for\n * details of `delete()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\ndelete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('DELETE', url, /** @type {?} */(( options as any)));\n  }\n\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  get(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  get<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * GET request to be executed on the server. See the individual overloads for\n * details of `get()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nget(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('GET', url, /** @type {?} */(( options as any)));\n  }\n\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n\n    /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  }): Observable<ArrayBuffer>;\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  head(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  head<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * HEAD request to be executed on the server. See the individual overloads for\n * details of `head()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nhead(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('HEAD', url, /** @type {?} */(( options as any)));\n  }\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as an `Object`\n   */\n  jsonp(url: string, callbackParam: string): Observable<Object>;\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as type `T`.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause a request\n * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n * \n * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n * If no such interceptor is reached, then the `JSONP` request will likely be\n * rejected by the configured backend.\n * @template T\n * @param {?} url\n * @param {?} callbackParam\n * @return {?}\n */\njsonp<T>(url: string, callbackParam: string): Observable<T> {\n    return this.request<any>('JSONP', url, {\n      params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Make an OPTIONS request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a OPTIONS request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  options(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  options<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * OPTIONS request to be executed on the server. See the individual overloads for\n * details of `options()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\noptions(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('OPTIONS', url, /** @type {?} */(( options as any)));\n  }\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  patch(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  patch<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * PATCH request to be executed on the server. See the individual overloads for\n * details of `patch()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npatch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PATCH', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  post(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  post<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See the individual overloads for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npost(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('POST', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  put(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  put<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See the individual overloads for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\nput(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PUT', url, addBody(options, body));\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: HttpHandler, },\n];\n}\n\nfunction HttpClient_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClient.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClient.ctorParameters;\n/** @type {?} */\nHttpClient.prototype.handler;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpHeaders} from './headers';\nexport type HttpEventType = number;\nexport let HttpEventType: any = {};\nHttpEventType.Sent = 0;\nHttpEventType.UploadProgress = 1;\nHttpEventType.ResponseHeader = 2;\nHttpEventType.DownloadProgress = 3;\nHttpEventType.Response = 4;\nHttpEventType.User = 5;\nHttpEventType[HttpEventType.Sent] = \"Sent\";\nHttpEventType[HttpEventType.UploadProgress] = \"UploadProgress\";\nHttpEventType[HttpEventType.ResponseHeader] = \"ResponseHeader\";\nHttpEventType[HttpEventType.DownloadProgress] = \"DownloadProgress\";\nHttpEventType[HttpEventType.Response] = \"Response\";\nHttpEventType[HttpEventType.User] = \"User\";\n\n/**\n * Base interface for progress events.\n * \n * \\@experimental\n * @record\n */\nexport function HttpProgressEvent() {}\n\n\nfunction HttpProgressEvent_tsickle_Closure_declarations() {\n/**\n * Progress event type is either upload or download.\n * @type {?}\n */\nHttpProgressEvent.prototype.type;\n/**\n * Number of bytes uploaded or downloaded.\n * @type {?}\n */\nHttpProgressEvent.prototype.loaded;\n/**\n * Total number of bytes to upload or download. Depending on the request or\n * response, this may not be computable and thus may not be present.\n * @type {?|undefined}\n */\nHttpProgressEvent.prototype.total;\n}\n\n\n/**\n * Base interface for progress events.\n *\n * @experimental\n */\nexport interface HttpProgressEvent {\n  /**\n   * Progress event type is either upload or download.\n   */\n  type: HttpEventType.DownloadProgress|HttpEventType.UploadProgress;\n\n  /**\n   * Number of bytes uploaded or downloaded.\n   */\n  loaded: number;\n\n  /**\n   * Total number of bytes to upload or download. Depending on the request or\n   * response, this may not be computable and thus may not be present.\n   */\n  total?: number;\n}\n/**\n * A download progress event.\n * \n * \\@experimental\n * @record\n */\nexport function HttpDownloadProgressEvent() {}\n\n\nfunction HttpDownloadProgressEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpDownloadProgressEvent.prototype.type;\n/**\n * The partial response body as downloaded so far.\n * \n * Only present if the responseType was `text`.\n * @type {?|undefined}\n */\nHttpDownloadProgressEvent.prototype.partialText;\n}\n\n\n/**\n * A download progress event.\n *\n * @experimental\n */\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.DownloadProgress;\n\n  /**\n   * The partial response body as downloaded so far.\n   *\n   * Only present if the responseType was `text`.\n   */\n  partialText?: string;\n}\n/**\n * An upload progress event.\n * \n * \\@experimental\n * @record\n */\nexport function HttpUploadProgressEvent() {}\n\n\nfunction HttpUploadProgressEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpUploadProgressEvent.prototype.type;\n}\n\n\n/**\n * An upload progress event.\n *\n * @experimental\n */\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.UploadProgress;\n}\n/**\n * An event indicating that the request was sent to the server. Useful\n * when a request may be retried multiple times, to distinguish between\n * retries on the final event stream.\n * \n * \\@experimental\n * @record\n */\nexport function HttpSentEvent() {}\n\n\nfunction HttpSentEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpSentEvent.prototype.type;\n}\n\n\n/**\n * An event indicating that the request was sent to the server. Useful\n * when a request may be retried multiple times, to distinguish between\n * retries on the final event stream.\n *\n * @experimental\n */\nexport interface HttpSentEvent { type: HttpEventType.Sent; }\n/**\n * A user-defined event.\n * \n * Grouping all custom events under this type ensures they will be handled\n * and forwarded by all implementations of interceptors.\n * \n * \\@experimental\n * @record\n */\nexport function HttpUserEvent() {}\n\n\nfunction HttpUserEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpUserEvent.prototype.type;\n}\n\n\n/**\n * A user-defined event.\n *\n * Grouping all custom events under this type ensures they will be handled\n * and forwarded by all implementations of interceptors.\n *\n * @experimental\n */\nexport interface HttpUserEvent<T> { type: HttpEventType.User; }\n/**\n * An error that represents a failed attempt to JSON.parse text coming back\n * from the server.\n * \n * It bundles the Error object with the actual response body that failed to parse.\n * \n * \\@experimental\n * @record\n */\nexport function HttpJsonParseError() {}\n\n\nfunction HttpJsonParseError_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpJsonParseError.prototype.error;\n/** @type {?} */\nHttpJsonParseError.prototype.text;\n}\n\n\n/**\n * An error that represents a failed attempt to JSON.parse text coming back\n * from the server.\n *\n * It bundles the Error object with the actual response body that failed to parse.\n *\n * @experimental\n */\nexport interface HttpJsonParseError {\n  error: Error;\n  text: string;\n}\n\n/**\n * Union type for all possible events on the response stream.\n *\n * Typed according to the expected type of the response.\n *\n * @experimental\n */\nexport type HttpEvent<T> =\n    HttpSentEvent | HttpHeaderResponse | HttpResponse<T>| HttpProgressEvent | HttpUserEvent<T>;\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpResponseBase {\n/**\n * All response headers.\n */\nreadonly headers: HttpHeaders;\n/**\n * Response status code.\n */\nreadonly status: number;\n/**\n * Textual description of response status code.\n * \n * Do not depend on this.\n */\nreadonly statusText: string;\n/**\n * URL of the resource retrieved, or null if not available.\n */\nreadonly url: string|null;\n/**\n * Whether the status code falls in the 2xx range.\n */\nreadonly ok: boolean;\n/**\n * Type of the response, narrowed to either the full response or the header.\n */\nreadonly type: HttpEventType.Response|HttpEventType.ResponseHeader;\n/**\n * Super-constructor for all responses.\n * \n * The single parameter accepted is an initialization hash. Any properties\n * of the response passed there will override the default values.\n * @param {?} init\n * @param {?=} defaultStatus\n * @param {?=} defaultStatusText\n */\nconstructor(\n      init: {\n        headers?: HttpHeaders,\n        status?: number,\n        statusText?: string,\n        url?: string,\n      },\n      defaultStatus: number = 200, defaultStatusText: string = 'OK') {\n    // If the hash has values passed, use them to initialize the response.\n    // Otherwise use the default values.\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== undefined ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n\n    // Cache the ok value to avoid defining a getter.\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n}\n\nfunction HttpResponseBase_tsickle_Closure_declarations() {\n/**\n * All response headers.\n * @type {?}\n */\nHttpResponseBase.prototype.headers;\n/**\n * Response status code.\n * @type {?}\n */\nHttpResponseBase.prototype.status;\n/**\n * Textual description of response status code.\n * \n * Do not depend on this.\n * @type {?}\n */\nHttpResponseBase.prototype.statusText;\n/**\n * URL of the resource retrieved, or null if not available.\n * @type {?}\n */\nHttpResponseBase.prototype.url;\n/**\n * Whether the status code falls in the 2xx range.\n * @type {?}\n */\nHttpResponseBase.prototype.ok;\n/**\n * Type of the response, narrowed to either the full response or the header.\n * @type {?}\n */\nHttpResponseBase.prototype.type;\n}\n\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n * \n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n * \n * \\@experimental\n */\nexport class HttpHeaderResponse extends HttpResponseBase {\n/**\n * Create a new `HttpHeaderResponse` with the given parameters.\n * @param {?=} init\n */\nconstructor(init: {\n    headers?: HttpHeaders,\n    status?: number,\n    statusText?: string,\n    url?: string,\n  } = {}) {\n    super(init);\n  }\n\n  readonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\n/**\n * Copy this `HttpHeaderResponse`, overriding its contents with the\n * given parameter hash.\n * @param {?=} update\n * @return {?}\n */\nclone(update: {headers?: HttpHeaders; status?: number; statusText?: string; url?: string;} = {}):\n      HttpHeaderResponse {\n    // Perform a straightforward initialization of the new HttpHeaderResponse,\n    // overriding the current parameters with new ones if given.\n    return new HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\nfunction HttpHeaderResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpHeaderResponse.prototype.type;\n}\n\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n * \n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n * \n * \\@experimental\n */\nexport class HttpResponse<T> extends HttpResponseBase {\n/**\n * The response body, or `null` if one was not returned.\n */\nreadonly body: T|null;\n/**\n * Construct a new `HttpResponse`.\n * @param {?=} init\n */\nconstructor(init: {\n    body?: T | null, headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  } = {}) {\n    super(init);\n    this.body = init.body || null;\n  }\n\n  readonly type: HttpEventType.Response = HttpEventType.Response;\n\n  clone(): HttpResponse<T>;\n  clone(update: {headers?: HttpHeaders; status?: number; statusText?: string; url?: string;}):\n      HttpResponse<T>;\n  clone<V>(update: {\n    body?: V | null, headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  }): HttpResponse<V>;\n/**\n * @param {?=} update\n * @return {?}\n */\nclone(update: {\n    body?: any | null; headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  } = {}): HttpResponse<any> {\n    return new HttpResponse<any>({\n      body: (update.body !== undefined) ? update.body : this.body,\n      headers: update.headers || this.headers,\n      status: (update.status !== undefined) ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\nfunction HttpResponse_tsickle_Closure_declarations() {\n/**\n * The response body, or `null` if one was not returned.\n * @type {?}\n */\nHttpResponse.prototype.body;\n/** @type {?} */\nHttpResponse.prototype.type;\n}\n\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n * \n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n * \n * \\@experimental\n */\nexport class HttpErrorResponse extends HttpResponseBase implements Error {\n  readonly name = 'HttpErrorResponse';\n  readonly message: string;\n  readonly error: any|null;\n/**\n * Errors are never okay, even when the status code is in the 2xx success range.\n */\nreadonly ok = false;\n/**\n * @param {?} init\n */\nconstructor(init: {\n    error?: any; headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  }) {\n    // Initialize with a default status of 0 / Unknown Error.\n    super(init, 0, 'Unknown Error');\n\n    // If the response was successful, then this was a parse error. Otherwise, it was\n    // a protocol-level failure of some sort. Either the request failed in transit\n    // or the server returned an unsuccessful status code.\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n    } else {\n      this.message =\n          `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n    }\n    this.error = init.error || null;\n  }\n}\n\nfunction HttpErrorResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpErrorResponse.prototype.name;\n/** @type {?} */\nHttpErrorResponse.prototype.message;\n/** @type {?} */\nHttpErrorResponse.prototype.error;\n/**\n * Errors are never okay, even when the status code is in the 2xx success range.\n * @type {?}\n */\nHttpErrorResponse.prototype.ok;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\n/**\n * Construction interface for `HttpRequest`s.\n * \n * All values are optional and will override default values if provided.\n * @record\n */\nfunction HttpRequestInit() {}\n\n\nfunction HttpRequestInit_tsickle_Closure_declarations() {\n/** @type {?|undefined} */\nHttpRequestInit.prototype.headers;\n/** @type {?|undefined} */\nHttpRequestInit.prototype.reportProgress;\n/** @type {?|undefined} */\nHttpRequestInit.prototype.params;\n/** @type {?|undefined} */\nHttpRequestInit.prototype.responseType;\n/** @type {?|undefined} */\nHttpRequestInit.prototype.withCredentials;\n}\n\n\n/**\n * Construction interface for `HttpRequest`s.\n *\n * All values are optional and will override default values if provided.\n */\ninterface HttpRequestInit {\n  headers?: HttpHeaders;\n  reportProgress?: boolean;\n  params?: HttpParams;\n  responseType?: 'arraybuffer'|'blob'|'json'|'text';\n  withCredentials?: boolean;\n}\n/**\n * Determine whether the given HTTP method may include a body.\n * @param {?} method\n * @return {?}\n */\nfunction mightHaveBody(method: string): boolean {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n * \n * In some execution environments ArrayBuffer is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n * \n * In some execution environments Blob is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n * \n * In some execution environments FormData is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * An outgoing HTTP request with an optional typed body.\n * \n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n * \n * \\@experimental\n */\nexport class HttpRequest<T> {\n/**\n * The request body, or `null` if one isn't set.\n * \n * Bodies are not enforced to be immutable, as they can include a reference to any\n * user-defined data type. However, interceptors should take care to preserve\n * idempotence by treating them as such.\n */\nreadonly body: T|null = null;\n/**\n * Outgoing headers for this request.\n */\nreadonly headers: HttpHeaders;\n/**\n * Whether this request should be made in a way that exposes progress events.\n * \n * Progress events are expensive (change detection runs on each event) and so\n * they should only be requested if the consumer intends to monitor them.\n */\nreadonly reportProgress: boolean = false;\n/**\n * Whether this request should be sent with outgoing credentials (cookies).\n */\nreadonly withCredentials: boolean = false;\n/**\n * The expected response type of the server.\n * \n * This is used to parse the response appropriately before returning it to\n * the requestee.\n */\nreadonly responseType: 'arraybuffer'|'blob'|'json'|'text' = 'json';\n/**\n * The outgoing HTTP request method.\n */\nreadonly method: string;\n/**\n * Outgoing URL parameters.\n */\nreadonly params: HttpParams;\n/**\n * The outgoing URL with all URL parameters set.\n */\nreadonly urlWithParams: string;\n/**\n * @param {?} method\n * @param {?} url\n * @param {?=} init\n */\nconstructor(method: 'DELETE'|'GET'|'HEAD'|'JSONP'|'OPTIONS', url: string, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n/**\n * @param {?} method\n * @param {?} url\n * @param {?} body\n * @param {?=} init\n */\nconstructor(method: 'POST'|'PUT'|'PATCH', url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n/**\n * @param {?} method\n * @param {?} url\n * @param {?} body\n * @param {?=} init\n */\nconstructor(method: string, url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n/**\n * @param {?} method\n * @param {?} url\n * @param {?=} third\n * @param {?=} fourth\n */\nconstructor(\n      method: string, readonly url: string, third?: T|{\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }|null,\n      fourth?: {\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }) {\n    this.method = method.toUpperCase();\n    // Next, need to figure out which argument holds the HttpRequestInit\n    // options, if any.\n    let /** @type {?} */ options: HttpRequestInit|undefined;\n\n    // Check whether a body argument is expected. The only valid way to omit\n    // the body argument is to use a known no-body method like GET.\n    if (mightHaveBody(this.method) || !!fourth) {\n      // Body is the third argument, options are the fourth.\n      this.body = /** @type {?} */(( third as T)) || null;\n      options = fourth;\n    } else {\n      // No body required, options are the third argument. The body stays null.\n      options = /** @type {?} */(( third as HttpRequestInit));\n    }\n\n    // If options have been passed, interpret them.\n    if (options) {\n      // Normalize reportProgress and withCredentials.\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n\n      // Override default response type of 'json' if one is provided.\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n\n      // Override headers if they're provided.\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n\n      if (!!options.params) {\n        this.params = options.params;\n      }\n    }\n\n    // If no headers have been passed in, construct a new HttpHeaders instance.\n    if (!this.headers) {\n      this.headers = new HttpHeaders();\n    }\n\n    // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      // Encode the parameters to a string in preparation for inclusion in the URL.\n      const /** @type {?} */ params = this.params.toString();\n      if (params.length === 0) {\n        // No parameters, the visible URL is just the URL given at creation time.\n        this.urlWithParams = url;\n      } else {\n        // Does the URL already have query parameters? Look for '?'.\n        const /** @type {?} */ qIdx = url.indexOf('?');\n        // There are 3 cases to handle:\n        // 1) No existing parameters -> append '?' followed by params.\n        // 2) '?' exists and is followed by existing query string ->\n        //    append '&' followed by params.\n        // 3) '?' exists at the end of the url -> append params directly.\n        // This basically amounts to determining the character, if any, with\n        // which to join the URL and parameters.\n        const /** @type {?} */ sep: string = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n/**\n * Transform the free-form body into a serialized format suitable for\n * transmission to the server.\n * @return {?}\n */\nserializeBody(): ArrayBuffer|Blob|FormData|string|null {\n    // If no body is present, no need to serialize it.\n    if (this.body === null) {\n      return null;\n    }\n    // Check whether the body is already in a serialized form. If so,\n    // it can just be returned directly.\n    if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n        typeof this.body === 'string') {\n      return this.body;\n    }\n    // Check whether the body is an instance of HttpUrlEncodedParams.\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    // Check whether the body is an object or array, and serialize with JSON if so.\n    if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n        Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    // Fall back on toString() for everything else.\n    return ( /** @type {?} */((this.body as any))).toString();\n  }\n/**\n * Examine the body and attempt to infer an appropriate MIME type\n * for it.\n * \n * If no such type can be inferred, this method will return `null`.\n * @return {?}\n */\ndetectContentTypeHeader(): string|null {\n    // An empty body has no content type.\n    if (this.body === null) {\n      return null;\n    }\n    // FormData bodies rely on the browser's content type assignment.\n    if (isFormData(this.body)) {\n      return null;\n    }\n    // Blobs usually have their own content type. If it doesn't, then\n    // no type can be inferred.\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    // Array buffers have unknown contents and thus no type can be inferred.\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    // Technically, strings could be a form of JSON data, but it's safe enough\n    // to assume they're plain strings.\n    if (typeof this.body === 'string') {\n      return 'text/plain';\n    }\n    // `HttpUrlEncodedParams` has its own content-type.\n    if (this.body instanceof HttpParams) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    // Arrays, objects, and numbers will be encoded as JSON.\n    if (typeof this.body === 'object' || typeof this.body === 'number' ||\n        Array.isArray(this.body)) {\n      return 'application/json';\n    }\n    // No type could be inferred.\n    return null;\n  }\n\n  clone(): HttpRequest<T>;\n  clone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: T|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<T>;\n  clone<V>(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: V|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<V>;\n/**\n * @param {?=} update\n * @return {?}\n */\nclone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: any|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string};\n  } = {}): HttpRequest<any> {\n    // For method, url, and responseType, take the current value unless\n    // it is overridden in the update hash.\n    const /** @type {?} */ method = update.method || this.method;\n    const /** @type {?} */ url = update.url || this.url;\n    const /** @type {?} */ responseType = update.responseType || this.responseType;\n\n    // The body is somewhat special - a `null` value in update.body means\n    // whatever current body is present is being overridden with an empty\n    // body, whereas an `undefined` value in update.body implies no\n    // override.\n    const /** @type {?} */ body = (update.body !== undefined) ? update.body : this.body;\n\n    // Carefully handle the boolean options to differentiate between\n    // `false` and `undefined` in the update args.\n    const /** @type {?} */ withCredentials =\n        (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n    const /** @type {?} */ reportProgress =\n        (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n\n    // Headers and params may be appended to if `setHeaders` or\n    // `setParams` are used.\n    let /** @type {?} */ headers = update.headers || this.headers;\n    let /** @type {?} */ params = update.params || this.params;\n\n    // Check whether the caller has asked to add headers.\n    if (update.setHeaders !== undefined) {\n      // Set every requested header.\n      headers =\n          Object.keys(update.setHeaders)\n              .reduce((headers, name) => headers.set(name, /** @type {?} */(( update.setHeaders))[name]), headers);\n    }\n\n    // Check whether the caller has asked to set params.\n    if (update.setParams) {\n      // Set every requested param.\n      params = Object.keys(update.setParams)\n                   .reduce((params, param) => params.set(param, /** @type {?} */(( update.setParams))[param]), params);\n    }\n\n    // Finally, construct the new HttpRequest using the pieces from above.\n    return new HttpRequest(\n        method, url, body, {\n                               params, headers, reportProgress, responseType, withCredentials,\n                           });\n  }\n}\n\nfunction HttpRequest_tsickle_Closure_declarations() {\n/**\n * The request body, or `null` if one isn't set.\n * \n * Bodies are not enforced to be immutable, as they can include a reference to any\n * user-defined data type. However, interceptors should take care to preserve\n * idempotence by treating them as such.\n * @type {?}\n */\nHttpRequest.prototype.body;\n/**\n * Outgoing headers for this request.\n * @type {?}\n */\nHttpRequest.prototype.headers;\n/**\n * Whether this request should be made in a way that exposes progress events.\n * \n * Progress events are expensive (change detection runs on each event) and so\n * they should only be requested if the consumer intends to monitor them.\n * @type {?}\n */\nHttpRequest.prototype.reportProgress;\n/**\n * Whether this request should be sent with outgoing credentials (cookies).\n * @type {?}\n */\nHttpRequest.prototype.withCredentials;\n/**\n * The expected response type of the server.\n * \n * This is used to parse the response appropriately before returning it to\n * the requestee.\n * @type {?}\n */\nHttpRequest.prototype.responseType;\n/**\n * The outgoing HTTP request method.\n * @type {?}\n */\nHttpRequest.prototype.method;\n/**\n * Outgoing URL parameters.\n * @type {?}\n */\nHttpRequest.prototype.params;\n/**\n * The outgoing URL with all URL parameters set.\n * @type {?}\n */\nHttpRequest.prototype.urlWithParams;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @record\n */\nfunction Update() {}\n\n\nfunction Update_tsickle_Closure_declarations() {\n/** @type {?} */\nUpdate.prototype.name;\n/** @type {?|undefined} */\nUpdate.prototype.value;\n/** @type {?} */\nUpdate.prototype.op;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ninterface Update {\n  name: string;\n  value?: string|string[];\n  op: 'a'|'s'|'d';\n}\n/**\n * Immutable set of Http headers, with lazy parsing.\n * \\@experimental\n */\nexport class HttpHeaders {\n/**\n * Internal map of lowercase header names to values.\n */\n\nprivate headers: Map<string, string[]>;\n/**\n * Internal map of lowercased header names to the normalized\n * form of the name (the form seen first).\n */\n\nprivate normalizedNames: Map<string, string> = new Map();\n/**\n * Complete the lazy initialization of this object (needed before reading).\n */\n\nprivate lazyInit: HttpHeaders|Function|null;\n/**\n * Queued updates to be materialized the next initialization.\n */\n\nprivate lazyUpdate: Update[]|null = null;\n/**\n * @param {?=} headers\n */\nconstructor(headers?: string|{[name: string]: string | string[]}) {\n    if (!headers) {\n      this.headers = new Map<string, string[]>();\n    } else if (typeof headers === 'string') {\n      this.lazyInit = () => {\n        this.headers = new Map<string, string[]>();\n        headers.split('\\n').forEach(line => {\n          const /** @type {?} */ index = line.indexOf(':');\n          if (index > 0) {\n            const /** @type {?} */ name = line.slice(0, index);\n            const /** @type {?} */ key = name.toLowerCase();\n            const /** @type {?} */ value = line.slice(index + 1).trim();\n            this.maybeSetNormalizedName(name, key);\n            if (this.headers.has(key)) { /** @type {?} */((\n              this.headers.get(key))).push(value);\n            } else {\n              this.headers.set(key, [value]);\n            }\n          }\n        });\n      };\n    } else {\n      this.lazyInit = () => {\n        this.headers = new Map<string, string[]>();\n        Object.keys(headers).forEach(name => {\n          let /** @type {?} */ values: string|string[] = headers[name];\n          const /** @type {?} */ key = name.toLowerCase();\n          if (typeof values === 'string') {\n            values = [values];\n          }\n          if (values.length > 0) {\n            this.headers.set(key, values);\n            this.maybeSetNormalizedName(name, key);\n          }\n        });\n      };\n    }\n  }\n/**\n * Checks for existence of header by given name.\n * @param {?} name\n * @return {?}\n */\nhas(name: string): boolean {\n    this.init();\n\n    return this.headers.has(name.toLowerCase());\n  }\n/**\n * Returns first header that matches given name.\n * @param {?} name\n * @return {?}\n */\nget(name: string): string|null {\n    this.init();\n\n    const /** @type {?} */ values = this.headers.get(name.toLowerCase());\n    return values && values.length > 0 ? values[0] : null;\n  }\n/**\n * Returns the names of the headers\n * @return {?}\n */\nkeys(): string[] {\n    this.init();\n\n    return Array.from(this.normalizedNames.values());\n  }\n/**\n * Returns list of header values for a given name.\n * @param {?} name\n * @return {?}\n */\ngetAll(name: string): string[]|null {\n    this.init();\n\n    return this.headers.get(name.toLowerCase()) || null;\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nappend(name: string, value: string|string[]): HttpHeaders {\n    return this.clone({name, value, op: 'a'});\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nset(name: string, value: string|string[]): HttpHeaders {\n    return this.clone({name, value, op: 's'});\n  }\n/**\n * @param {?} name\n * @param {?=} value\n * @return {?}\n */\ndelete (name: string, value?: string|string[]): HttpHeaders {\n    return this.clone({name, value, op: 'd'});\n  }\n/**\n * @param {?} name\n * @param {?} lcName\n * @return {?}\n */\n\nprivate maybeSetNormalizedName(name: string, lcName: string): void {\n    if (!this.normalizedNames.has(lcName)) {\n      this.normalizedNames.set(lcName, name);\n    }\n  }\n/**\n * @return {?}\n */\n\nprivate init(): void {\n    if (!!this.lazyInit) {\n      if (this.lazyInit instanceof HttpHeaders) {\n        this.copyFrom(this.lazyInit);\n      } else {\n        this.lazyInit();\n      }\n      this.lazyInit = null;\n      if (!!this.lazyUpdate) {\n        this.lazyUpdate.forEach(update => this.applyUpdate(update));\n        this.lazyUpdate = null;\n      }\n    }\n  }\n/**\n * @param {?} other\n * @return {?}\n */\n\nprivate copyFrom(other: HttpHeaders) {\n    other.init();\n    Array.from(other.headers.keys()).forEach(key => {\n      this.headers.set(key, /** @type {?} */(( other.headers.get(key))));\n      this.normalizedNames.set(key, /** @type {?} */(( other.normalizedNames.get(key))));\n    });\n  }\n/**\n * @param {?} update\n * @return {?}\n */\n\nprivate clone(update: Update): HttpHeaders {\n    const /** @type {?} */ clone = new HttpHeaders();\n    clone.lazyInit =\n        (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\n    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n    return clone;\n  }\n/**\n * @param {?} update\n * @return {?}\n */\n\nprivate applyUpdate(update: Update): void {\n    const /** @type {?} */ key = update.name.toLowerCase();\n    switch (update.op) {\n      case 'a':\n      case 's':\n        let /** @type {?} */ value = /** @type {?} */(( update.value));\n        if (typeof value === 'string') {\n          value = [value];\n        }\n        if (value.length === 0) {\n          return;\n        }\n        this.maybeSetNormalizedName(update.name, key);\n        const /** @type {?} */ base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n        base.push(...value);\n        this.headers.set(key, base);\n        break;\n      case 'd':\n        const /** @type {?} */ toDelete = /** @type {?} */(( update.value as string | undefined));\n        if (!toDelete) {\n          this.headers.delete(key);\n          this.normalizedNames.delete(key);\n        } else {\n          let /** @type {?} */ existing = this.headers.get(key);\n          if (!existing) {\n            return;\n          }\n          existing = existing.filter(value => toDelete.indexOf(value) === -1);\n          if (existing.length === 0) {\n            this.headers.delete(key);\n            this.normalizedNames.delete(key);\n          } else {\n            this.headers.set(key, existing);\n          }\n        }\n        break;\n    }\n  }\n/**\n * \\@internal\n * @param {?} fn\n * @return {?}\n */\nforEach(fn: (name: string, values: string[]) => void) {\n    this.init();\n    Array.from(this.normalizedNames.keys())\n        .forEach(key => fn( /** @type {?} */((this.normalizedNames.get(key))), /** @type {?} */(( this.headers.get(key)))));\n  }\n}\n\nfunction HttpHeaders_tsickle_Closure_declarations() {\n/**\n * Internal map of lowercase header names to values.\n * @type {?}\n */\nHttpHeaders.prototype.headers;\n/**\n * Internal map of lowercased header names to the normalized\n * form of the name (the form seen first).\n * @type {?}\n */\nHttpHeaders.prototype.normalizedNames;\n/**\n * Complete the lazy initialization of this object (needed before reading).\n * @type {?}\n */\nHttpHeaders.prototype.lazyInit;\n/**\n * Queued updates to be materialized the next initialization.\n * @type {?}\n */\nHttpHeaders.prototype.lazyUpdate;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\n/**\n * A codec for encoding and decoding parameters in URLs.\n * \n * Used by `HttpParams`.\n * \n *  \\@experimental\n * \n * @record\n */\nexport function HttpParameterCodec() {}\n\n\nfunction HttpParameterCodec_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpParameterCodec.prototype.encodeKey;\n/** @type {?} */\nHttpParameterCodec.prototype.encodeValue;\n/** @type {?} */\nHttpParameterCodec.prototype.decodeKey;\n/** @type {?} */\nHttpParameterCodec.prototype.decodeValue;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A codec for encoding and decoding parameters in URLs.\n *\n * Used by `HttpParams`.\n *\n *  @experimental\n **/\nexport interface HttpParameterCodec {\n  encodeKey(key: string): string;\n  encodeValue(value: string): string;\n\n  decodeKey(key: string): string;\n  decodeValue(value: string): string;\n}\n/**\n * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n * serialize and parse URL parameter keys and values.\n * \n * \\@experimental\n */\nexport class HttpUrlEncodingCodec implements HttpParameterCodec {\n/**\n * @param {?} k\n * @return {?}\n */\nencodeKey(k: string): string { return standardEncoding(k); }\n/**\n * @param {?} v\n * @return {?}\n */\nencodeValue(v: string): string { return standardEncoding(v); }\n/**\n * @param {?} k\n * @return {?}\n */\ndecodeKey(k: string): string { return decodeURIComponent(k); }\n/**\n * @param {?} v\n * @return {?}\n */\ndecodeValue(v: string) { return decodeURIComponent(v); }\n}\n/**\n * @param {?} rawParams\n * @param {?} codec\n * @return {?}\n */\nfunction paramParser(rawParams: string, codec: HttpParameterCodec): Map<string, string[]> {\n  const /** @type {?} */ map = new Map<string, string[]>();\n  if (rawParams.length > 0) {\n    const /** @type {?} */ params: string[] = rawParams.split('&');\n    params.forEach((param: string) => {\n      const /** @type {?} */ eqIdx = param.indexOf('=');\n      const [key, val]: string[] = eqIdx == -1 ?\n          [codec.decodeKey(param), ''] :\n          [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const /** @type {?} */ list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\n/**\n * @param {?} v\n * @return {?}\n */\nfunction standardEncoding(v: string): string {\n  return encodeURIComponent(v)\n      .replace(/%40/gi, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/gi, '$')\n      .replace(/%2C/gi, ',')\n      .replace(/%3B/gi, ';')\n      .replace(/%2B/gi, '+')\n      .replace(/%3D/gi, '=')\n      .replace(/%3F/gi, '?')\n      .replace(/%2F/gi, '/');\n}\n/**\n * @record\n */\nfunction Update() {}\n\n\nfunction Update_tsickle_Closure_declarations() {\n/** @type {?} */\nUpdate.prototype.param;\n/** @type {?|undefined} */\nUpdate.prototype.value;\n/** @type {?} */\nUpdate.prototype.op;\n}\n\n\ninterface Update {\n  param: string;\n  value?: string;\n  op: 'a'|'d'|'s';\n}\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n * \n * This class is immuatable - all mutation operations return a new instance.\n * \n * \\@experimental\n */\nexport class HttpParams {\nprivate map: Map<string, string[]>|null;\nprivate encoder: HttpParameterCodec;\nprivate updates: Update[]|null = null;\nprivate cloneFrom: HttpParams|null = null;\n/**\n * @param {?=} options\n */\nconstructor(options: {\n    fromString?: string,\n    encoder?: HttpParameterCodec,\n  } = {}) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    this.map = !!options.fromString ? paramParser(options.fromString, this.encoder) : null;\n  }\n/**\n * Check whether the body has one or more values for the given parameter name.\n * @param {?} param\n * @return {?}\n */\nhas(param: string): boolean {\n    this.init();\n    return /** @type {?} */(( this.map)).has(param);\n  }\n/**\n * Get the first value for the given parameter name, or `null` if it's not present.\n * @param {?} param\n * @return {?}\n */\nget(param: string): string|null {\n    this.init();\n    const /** @type {?} */ res = /** @type {?} */(( this.map)).get(param);\n    return !!res ? res[0] : null;\n  }\n/**\n * Get all values for the given parameter name, or `null` if it's not present.\n * @param {?} param\n * @return {?}\n */\ngetAll(param: string): string[]|null {\n    this.init();\n    return /** @type {?} */(( this.map)).get(param) || null;\n  }\n/**\n * Get all the parameter names for this body.\n * @return {?}\n */\nkeys(): string[] {\n    this.init();\n    return Array.from( /** @type {?} */((this.map)).keys());\n  }\n/**\n * Construct a new body with an appended value for the given parameter name.\n * @param {?} param\n * @param {?} value\n * @return {?}\n */\nappend(param: string, value: string): HttpParams { return this.clone({param, value, op: 'a'}); }\n/**\n * Construct a new body with a new value for the given parameter name.\n * @param {?} param\n * @param {?} value\n * @return {?}\n */\nset(param: string, value: string): HttpParams { return this.clone({param, value, op: 's'}); }\n/**\n * Construct a new body with either the given value for the given parameter\n * removed, if a value is given, or all values for the given parameter removed\n * if not.\n * @param {?} param\n * @param {?=} value\n * @return {?}\n */\ndelete (param: string, value?: string): HttpParams { return this.clone({param, value, op: 'd'}); }\n/**\n * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are\n * separated by `&`s.\n * @return {?}\n */\ntoString(): string {\n    this.init();\n    return this.keys()\n        .map(key => {\n          const /** @type {?} */ eKey = this.encoder.encodeKey(key);\n          return /** @type {?} */(( /** @type {?} */(( this.map)).get(key))).map(value => eKey + '=' + this.encoder.encodeValue(value))\n              .join('&');\n        })\n        .join('&');\n  }\n/**\n * @param {?} update\n * @return {?}\n */\n\nprivate clone(update: Update): HttpParams {\n    const /** @type {?} */ clone = new HttpParams({encoder: this.encoder});\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat([update]);\n    return clone;\n  }\n/**\n * @return {?}\n */\n\nprivate init() {\n    if (this.map === null) {\n      this.map = new Map<string, string[]>();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach(key => /** @type {?} */(( this.map)).set(key, /** @type {?} */(( /** @type {?} */(( /** @type {?} */(( this.cloneFrom)).map)).get(key))))); /** @type {?} */((\n      this.updates)).forEach(update => {\n        switch (update.op) {\n          case 'a':\n          case 's':\n            const /** @type {?} */ base = (update.op === 'a' ? /** @type {?} */(( this.map)).get(update.param) : undefined) || [];\n            base.push( /** @type {?} */((update.value))); /** @type {?} */((\n            this.map)).set(update.param, base);\n            break;\n          case 'd':\n            if (update.value !== undefined) {\n              let /** @type {?} */ base = /** @type {?} */(( this.map)).get(update.param) || [];\n              const /** @type {?} */ idx = base.indexOf(update.value);\n              if (idx !== -1) {\n                base.splice(idx, 1);\n              }\n              if (base.length > 0) { /** @type {?} */((\n                this.map)).set(update.param, base);\n              } else { /** @type {?} */((\n                this.map)).delete(update.param);\n              }\n            } else { /** @type {?} */((\n              this.map)).delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = null;\n    }\n  }\n}\n\nfunction HttpParams_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpParams.prototype.map;\n/** @type {?} */\nHttpParams.prototype.encoder;\n/** @type {?} */\nHttpParams.prototype.updates;\n/** @type {?} */\nHttpParams.prototype.cloneFrom;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs/Observable';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n * \n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n * \n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpHandler {\n  abstract handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n}\n\nfunction HttpHandler_tsickle_Closure_declarations() {\n\n/**\n * @abstract\n * @param {?} req\n * @return {?}\n */\nHttpHandler.prototype.handle = function(req) {};\n}\n\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n * \n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n * \n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpBackend implements HttpHandler {\n  abstract handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n}\n\nfunction HttpBackend_tsickle_Closure_declarations() {\n\n/**\n * @abstract\n * @param {?} req\n * @return {?}\n */\nHttpBackend.prototype.handle = function(req) {};\n}\n\n"],"names":["parseCookieValue","map"],"mappings":"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"}